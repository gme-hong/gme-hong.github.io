<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="Hong Nie"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://registry.npmmirror.com" crossorigin><link rel="canonical" href="https://gme-hong.github.io/2025/03/01/机式指南/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="机式重点永远是树结构、图结构以及动态规划！！！ 夏令营经典题型结构体排序问题这类问题往往都是一个模板，即待排序的数据都是结构体，排序规则涉及到结构体中的多个元素。 其中，结构体的构造部分尽可能使用struct而不是用class（这是因为，算法题中一般都只是涉及到“组织”的问题，因此完全不需要使用对“封装、继承”等相对完善的class）。 此外，排序规则需要构建一个返回值为bool，传递两个结构体元"><meta property="og:type" content="article"><meta property="og:title" content="机式指南"><meta property="og:url" content="https://gme-hong.github.io/2025/03/01/%E6%9C%BA%E5%BC%8F%E6%8C%87%E5%8D%97/index.html"><meta property="og:site_name" content="OpticHong&#39;s Blog"><meta property="og:description" content="机式重点永远是树结构、图结构以及动态规划！！！ 夏令营经典题型结构体排序问题这类问题往往都是一个模板，即待排序的数据都是结构体，排序规则涉及到结构体中的多个元素。 其中，结构体的构造部分尽可能使用struct而不是用class（这是因为，算法题中一般都只是涉及到“组织”的问题，因此完全不需要使用对“封装、继承”等相对完善的class）。 此外，排序规则需要构建一个返回值为bool，传递两个结构体元"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://ec28649.webp.li/20250301134944009.png"><meta property="og:image" content="https://ec28649.webp.li/20250301134959747.png"><meta property="og:image" content="https://ec28649.webp.li/20250301134853477.png"><meta property="og:image" content="https://ec28649.webp.li/20250301135049003.png"><meta property="og:image" content="https://ec28649.webp.li/20250301135101578.png"><meta property="og:image" content="https://ec28649.webp.li/20250301135119329.png"><meta property="og:image" content="https://ec28649.webp.li/20250301135135464.png"><meta property="og:image" content="https://ec28649.webp.li/20250301135145771.png"><meta property="og:image" content="https://ec28649.webp.li/20250301135200899.png"><meta property="article:published_time" content="2025-03-01T05:27:51.000Z"><meta property="article:modified_time" content="2025-03-01T05:53:38.095Z"><meta property="article:author" content="OpticHong"><meta property="article:tag" content="Algorithms"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://ec28649.webp.li/20250301134944009.png"><link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/images/favicon.ico"><title>机式指南 - OpticHong</title><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/fonts/Chillax/chillax.css"><link rel="stylesheet" href="https://gme-hong.github.io/notes/ravel-light.css"><link rel="stylesheet" type="text/css" href="//at.alicdn.com/t/c/font_4973007_vi96klaq9o8.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/assets/build/styles.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/fonts/Geist/geist.css"><link href="https://fonts.googleapis.com/css2?family=Tilt+Neon&display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200..900&display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css2?family=Alice&display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css2?family=Alice&display=swap" rel="stylesheet"><script id="hexo-configurations">window.config={hostname:"gme-hong.github.io",root:"/",language:"en",path:"search.json"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"4px",image_alignment:"center",image_caption:!1,link_icon:!0,title_alignment:"left",headings_top_spacing:{h1:"3rem",h2:"2.5rem",h3:"2.2rem",h4:"1.8rem",h5:"1.4rem",h6:"1.0rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:["Lv.8"]},code_block:{copy:!0,style:"mac",font:{enable:!1,family:"Noto Sans",url:"https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&display=swap"}},toc:{enable:!0,max_depth:6,number:!0,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,recommendation:{enable:!0,title:"Recommendation",limit:3,mobile_limit:2,placeholder:"/images/background-light.jpg",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null,default_mode:"dark"},global:{fonts:{chinese:{enable:!0,family:"Noto Serif Simplified Chinese",url:"https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200..900&display=swap"},english:{enable:!0,family:"Alice",url:"https://fonts.googleapis.com/css2?family=Alice&display=swap"},title:{enable:!0,family:"Alice",url:"https://fonts.googleapis.com/css2?family=Alice&display=swap"}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!1},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!1,custom_message:null},open_graph:!0,google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/background-light.jpg",dark:"/images/background-dark.jpg"},title:"Hong Nie's Blog",subtitle:{text:["莫愁前路无知己，天下谁人不识君。"],hitokoto:{enable:!1,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:60,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!0,family:"Tilt Neon",url:"https://fonts.googleapis.com/css2?family=Tilt+Neon&display=swap"},social_links:{enable:!0,style:"default",links:{github:"https://github.com/gme-hong","fa-brands fa-git-alt":"https://gitee.com/optichong",instagram:"https://www.instagram.com/optichong/",twitter:"https://twitter.com/OpticHong",zhihu:"https://www.zhihu.com/people/OpticHong",email:"info@optichong.cn","fa-solid fa-square-rss":["https://gme-hong.github.io/atom.xml"]},qrs:{weixin:"/images/sponsors.jpg"}}},plugins:{feed:{enable:!1,type:"atom",path:"atom.xml",limit:20,hub:null,content:null,content_limit:140,content_limit_delim:" ",order_by:"-date",icon:"/images/favicon.jpg",autodiscovery:!0,template:null},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!0,version:"9.3.0"},mathjax:{tags:"none",single_dollars:!0,cjk_width:.9,normal_width:.6,append_css:!0,every_page:!1}},version:"2.7.1",navbar:{auto_hide:!1,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-solid fa-house"},Archives:{path:"/archives/",icon:"fa-solid fa-inbox"},Essays:{path:"/essays/",icon:"fa-solid fa-messages"},Papers:{path:"/papers/",icon:"fa-solid fa-newspaper"},About:{icon:"fa-solid fa-user",submenus:{Me:"/about/",Github:"https://github.com/gme-hong",Gallery:"/masonry/"}}},search:{enable:!0,preload:!0,icon:"fa-solid fa-magnifying-glass"}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:null,show_on_mobile:!0,links:{Tags:{path:"/tags/",icon:"fa-regular fa-tags"},Papers:{path:"/papers/",icon:"fa-solid fa-newspaper"},Archives:{path:"/archives/",icon:"fa-solid fa-inbox"},Categories:{path:"/categories/",icon:"fa-solid fa-layer-group"}}},article_date_format:"auto",categories:{enable:!0,limit:6},tags:{enable:!0,limit:5}},footerStart:"2022/3/10 00:00:00"},window.lang_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},window.data={masonry:!0}</script><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/fontawesome/brands.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/fontawesome/solid.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/fontawesome/regular.min.css"><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="OpticHong's Blog" type="application/atom+xml">
</head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><main class="page-container" id="swup"><div class="main-content-container"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content"><div class="left"><a class="logo-image" href="/"><img src="/images/favicon.jpg"> </a><a class="logo-title" href="/">OpticHong</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-solid fa-house fa-fw"></i> HOME</a></li><li class="navbar-item"><a href="/archives/"><i class="fa-solid fa-inbox fa-fw"></i> ARCHIVES</a></li><li class="navbar-item"><a href="/essays/"><i class="fa-solid fa-messages fa-fw"></i> ESSAYS</a></li><li class="navbar-item"><a href="/papers/"><i class="fa-solid fa-newspaper fa-fw"></i> PAPERS</a></li><li class="navbar-item"><a class="has-dropdown" href="#" onclick="&#34;return" false;&#34;><i class="fa-solid fa-user fa-fw"></i> ABOUT <i class="fa-solid fa-chevron-down fa-fw"></i></a><ul class="sub-menu"><li><a href="/about/">ME</a></li><li><a target="_blank" rel="noopener" href="https://github.com/gme-hong">GITHUB</a></li><li><a href="/masonry/">GALLERY</a></li></ul></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>HOME </span><i class="fa-solid fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/archives/"><span>ARCHIVES </span><i class="fa-solid fa-inbox fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/essays/"><span>ESSAYS </span><i class="fa-solid fa-messages fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/papers/"><span>PAPERS </span><i class="fa-solid fa-newspaper fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full"><div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" navbar-data-toggle="submenu-About"><span>ABOUT </span><i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i></div><div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-About"><div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl"><a class="text-third-text-color text-xl" href="/about/">ME</a></div><div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl"><a class="text-third-text-color text-xl" target="_blank" rel="noopener" href="https://github.com/gme-hong">GITHUB</a></div><div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl"><a class="text-third-text-color text-xl" href="/masonry/">GALLERY</a></div></div></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/tags/"><span>Tags</span> <i class="fa-regular fa-tags fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/categories/"><span>Categories</span> <i class="fa-solid fa-layer-group fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">6</div><div class="label text-third-text-color text-sm">Tags</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">2</div><div class="label text-third-text-color text-sm">Categories</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">12</div><div class="label text-third-text-color text-sm">Posts</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">机式指南</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/favicon.jpg"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">Hong Nie</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv.8</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2025-03-01 13:27:51</span> <span class="mobile">2025-03-01 13:27:51</span> <span class="hover-info">Created</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2025-03-01 13:53:38</span> <span class="mobile">2025-03-01 13:53:38</span> <span class="hover-info">Updated</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/Notes/">Notes</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/Algorithms/">Algorithms</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>24.3k Words</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>112 Mins</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><p>机式重点永远是<strong>树结构</strong>、<strong>图结构</strong>以及<strong>动态规划</strong>！！！</p><h2 id="夏令营经典题型"><a href="#夏令营经典题型" class="headerlink" title="夏令营经典题型"></a>夏令营经典题型</h2><h3 id="结构体排序问题"><a href="#结构体排序问题" class="headerlink" title="结构体排序问题"></a>结构体排序问题</h3><p>这类问题往往都是一个模板，即待排序的数据都是结构体，排序规则涉及到结构体中的多个元素。</p><p>其中，<strong>结构体的构造部分尽可能使用struct而不是用class</strong>（这是因为，算法题中一般都只是涉及到“组织”的问题，因此完全不需要使用对“封装、继承”等相对完善的class）。</p><p>此外，排序规则需要构建一个返回值为bool，传递两个结构体元素的比较函数<code>bool cmp(Elem e1,Elem e2)</code>，具体函数内的返回规则需要根据题目所给的判断逻辑进行编写。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">cosnt <span class="type">int</span> N =<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Elem</span>&#123;</span><br><span class="line">	string str;<span class="comment">// 如果不支持c++，则需要改成字符数组 char str[30];此外进行字符串比较时，需要利用strcmp(s1,s2)进行比较。</span></span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">double</span> socre;</span><br><span class="line">&#125;Stu[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Elem e1, Elem e2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(e1.socre != e2.socre) <span class="keyword">return</span> e1.socre &lt; e2.socre;<span class="comment">//这是升序排列</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(e1.str != e2.str) <span class="keyword">return</span> e1.str &lt; e2.str;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> e1.age &lt; e2.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//首先是输入逻辑部分，对结构体进行填充。</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;Stu[i].str&gt;&gt;Stu[i].age&gt;&gt;Stu[i].socre;</span><br><span class="line">  <span class="comment">//对结构体中的数据，利用内置函数sort进行排序。</span></span><br><span class="line">  <span class="built_in">sort</span>(Stu,Stu+n,cmp);</span><br><span class="line">  <span class="comment">//最后根据题目所给要求进行输出。</span></span><br><span class="line">  cout&lt;&lt;Stu[<span class="number">0</span>].str&lt;&lt;Stu[<span class="number">0</span>].age&lt;&lt;Stu[<span class="number">0</span>].score;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义结构体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Elem</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义比较函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmp</span>(<span class="params">elem</span>):</span><br><span class="line">    <span class="comment"># 按照分数升序排列，如果分数相同，则按照名字升序排列，再按照年龄升序排列</span></span><br><span class="line">    <span class="keyword">return</span> (elem.score, elem.name, elem.age)</span><br><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">在 Python 中，sort 和 <span class="built_in">sorted</span> 函数支持通过 key 参数指定排序规则，而 key 参数需要传入一个函数，该函数会对每个元素进行处理，返回一个可以比较的值（如数字或元组）。根据这个返回值，Python 会对所有元素进行排序。</span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 输入数据</span></span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    students = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        name, age, score = <span class="built_in">input</span>().split()  </span><br><span class="line">        age = <span class="built_in">int</span>(age)</span><br><span class="line">        score = <span class="built_in">float</span>(score)</span><br><span class="line">        students.append(Elem(name, age, score))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对数据进行排序</span></span><br><span class="line">    students.sort(key=cmp)  <span class="comment">#默认是整体升序排列，如果需要整体降序，参数reverse可以置为True。如果排序中的某一非数值属性需要降序，则将字符串进行反转[::-1]，数值属性需要降序直接加负号即可。如果需要按照字符串第一个字符进行排序可以使用ord()函数。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出第一个学生的信息</span></span><br><span class="line">    <span class="built_in">print</span>(students[<span class="number">0</span>].name, students[<span class="number">0</span>].age, students[<span class="number">0</span>].score)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>这种题目的变体，多集中在模板中最关键的两步，即<strong>是否待排序的元素需要构建结构体</strong>，以及<strong>需要构建多个排序规则</strong>。</p><ol><li><p><a class="link" target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/dfeed0e0e4624814b122265e859783b2">是否需要构建结构体？ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>当涉及到待排序元素有多个属性时，这个时候毫无疑问构建结构体是一种不错的结果方案；</p><p>但是，待排序元素就只用单一属性时，这个时候也可能需要构建结构体。此时，我们需要明白构建结构体的目的是为了更方便的排序，是因为但从其自身的属性上已经不好进行快速比较时，才将比较的逻辑单独抽离出来。<code>比如说，字符串的排序，但排序的逻辑不再是字符串的字典序，而是其字符串的长度。</code></p></li><li><p><a class="link" target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/bf3ec474bb7d410dbb9d5bbcd07a93e5">构建多个排序规则。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>多个和单个排序规则本质上没有太大区别。注意到题目中如果有多种情况需要利用到不同的排序规则时，在代码中需要使用<code>case</code>进行实现。</p></li></ol><h3 id="日期类问题"><a href="#日期类问题" class="headerlink" title="日期类问题"></a>日期类问题</h3><p>这类问题往往属于模拟的大类，其最明显的特点就是没有难以理解的算法，更多的是进行模拟。</p><p>其中涉及到的知识点有：<strong>闰年判断</strong>、1年1月1日为星期一</p><p><strong>额外需要注意的就是这几个周期和月份单词的拼写</strong>。</p><h4 id="间隔时间"><a href="#间隔时间" class="headerlink" title="间隔时间"></a>间隔时间</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> date[<span class="number">2</span>][<span class="number">13</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;,&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;&#125;; <span class="comment">//首先定义每月天数，将闰月年区分开来，方便后面判断完闰年后的月份天数确定。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLeap</span><span class="params">(<span class="type">int</span> year)</span></span>&#123; <span class="comment">//判断闰年的函数，被400整除或者被4整除但不被100整除</span></span><br><span class="line">  <span class="keyword">return</span> ((year%<span class="number">4</span>==<span class="number">0</span>)&amp;&amp;(year%<span class="number">100</span>!=<span class="number">0</span>)) || (year%<span class="number">400</span>==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> time1,time2,y1,y2,m1,m2,d1,d2;</span><br><span class="line">  <span class="keyword">while</span>(cin&gt;&gt;time1&gt;&gt;time2)&#123;</span><br><span class="line">    <span class="keyword">if</span>(time1&gt;time2)&#123;<span class="type">int</span> tmp=time2;time2=time1;time1=time2;&#125;</span><br><span class="line">    <span class="comment">//需要前面的数字就用除，需要后面的数字就用模</span></span><br><span class="line">    y1=time1/<span class="number">10000</span>,m1=time1%<span class="number">10000</span>/<span class="number">100</span>,d1=time1%<span class="number">100</span>;</span><br><span class="line">    y2=time2/<span class="number">10000</span>,m2=time2%<span class="number">10000</span>/<span class="number">100</span>,d2=time2%<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y1&lt;y2 || m1&lt;m2 || d1&lt;d2)&#123; <span class="comment">//使用天数累加的方式进行模拟</span></span><br><span class="line">      d1++;</span><br><span class="line">      <span class="keyword">if</span>(d1==date[<span class="built_in">isLeap</span>(y1)][m1]+<span class="number">1</span>)&#123;m1++;d1=<span class="number">1</span>;&#125;</span><br><span class="line">      <span class="keyword">if</span>(m1==<span class="number">13</span>)&#123;y1++;m1=<span class="number">1</span>;&#125;</span><br><span class="line">      sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">date=[</span><br><span class="line">    [<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_leap</span>(<span class="params">year</span>):</span><br><span class="line">    <span class="keyword">return</span> (year%<span class="number">4</span>==<span class="number">0</span> <span class="keyword">and</span> year%<span class="number">100</span>!=<span class="number">0</span>) <span class="keyword">or</span> year%<span class="number">400</span>==<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    sum_date=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            time1,time2=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">            <span class="keyword">if</span> time1&gt;time2:</span><br><span class="line">                time1,time2=time2,time1</span><br><span class="line">            year1,month1,day1=time1//<span class="number">10000</span>,time1%<span class="number">10000</span>//<span class="number">100</span>,time1%<span class="number">100</span></span><br><span class="line">            year2,month2,day2=time2//<span class="number">10000</span>,time2%<span class="number">10000</span>//<span class="number">100</span>,time2%<span class="number">100</span></span><br><span class="line">            <span class="keyword">while</span> year1&lt;year2 <span class="keyword">or</span> month1&lt;month2 <span class="keyword">or</span> day1&lt;day2:</span><br><span class="line">                day1+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> day1==date[is_leap(year1)][month1]+<span class="number">1</span>:</span><br><span class="line">                    day1=<span class="number">1</span></span><br><span class="line">                    month1+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> month1==<span class="number">13</span>:</span><br><span class="line">                    month1=<span class="number">1</span></span><br><span class="line">                    year1+=<span class="number">1</span></span><br><span class="line">                sum_date+=<span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(sum_date)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">main() </span><br></pre></td></tr></table></figure></div><h4 id="判断星期"><a href="#判断星期" class="headerlink" title="判断星期"></a>判断星期</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isleap</span><span class="params">(<span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span>) || y % <span class="number">400</span> == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="type">int</span> m[<span class="number">2</span>][<span class="number">13</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;&#125;;</span><br><span class="line">string week[<span class="number">7</span>] = &#123;<span class="string">&quot;Sunday&quot;</span>,<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>,<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>&#125;;</span><br><span class="line">string mouth[<span class="number">13</span>] = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;January&quot;</span>,<span class="string">&quot;February&quot;</span>,<span class="string">&quot;March&quot;</span>,<span class="string">&quot;April&quot;</span>,<span class="string">&quot;May&quot;</span>,<span class="string">&quot;June&quot;</span>,<span class="string">&quot;July&quot;</span>,<span class="string">&quot;August&quot;</span>,<span class="string">&quot;September&quot;</span>,<span class="string">&quot;October&quot;</span>,<span class="string">&quot;November&quot;</span>,<span class="string">&quot;December&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> d2, m2, y2, d1 = <span class="number">1</span>, m1 = <span class="number">1</span>, y1 = <span class="number">1</span>;</span><br><span class="line">  string mm;</span><br><span class="line">  cin &gt;&gt; d2 &gt;&gt; mm &gt;&gt; y2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++)</span><br><span class="line">    <span class="keyword">if</span> (mm == mouth[i]) &#123;m2 = i;<span class="keyword">break</span>;&#125;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (d1 &lt; d2 || m1 &lt; m2 || y1 &lt; y2) &#123;</span><br><span class="line">    d1++;</span><br><span class="line">    <span class="keyword">if</span> (d1 == m[<span class="built_in">isleap</span>(y1)][m1] + <span class="number">1</span>) &#123;d1 = <span class="number">1</span>;m1++;&#125;</span><br><span class="line">    <span class="keyword">if</span> (m1 == <span class="number">13</span>) &#123;m1 = <span class="number">1</span>;y1++;&#125;</span><br><span class="line">    sum++;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; week[sum % <span class="number">7</span>] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="C-C-快速入门"><a href="#C-C-快速入门" class="headerlink" title="C&#x2F;C++快速入门"></a>C&#x2F;C++快速入门</h2><ol><li><p>绝对值在$10^9$范围以内的整数都可以定义为int型。其他情况，使用<code>typedef long long ll;</code>类型，以及unsigned long long (ull)类型。</p></li><li><p><code>const int INF=0x3fffffff;</code></p></li><li><p><code>cout&lt;&lt;fixed&lt;&lt;setw(7)&lt;&lt;setprecision(2)&lt;&lt;x&lt;&lt;endl;</code>设置输出x的宽度为7，其中小数部分占2位。</p></li><li><p>浮点数比较大小：</p><p><code>const double eps=1e-8;</code></p><p>等于：<code>#define equ(a,b) fabs(a-b)&lt;eps</code></p><p>大于：<code>#define more(a,b) (a-b)&gt;eps</code></p><p>小于：<code>#define less(a,b) (a-b)&lt;-eps</code></p><p>大于等于：<code>#define more_eq(a,b) (a-b)&gt;-eps</code></p><p>小于等于：<code>#define less_eq(a,b) (a-b)&lt;eps</code></p></li><li><p>π值：<code>const double pi=acos(-1.0);</code></p></li><li><p>如果两个操作数都是整数类型（例如 <code>int</code>、<code>long</code>、<code>long long</code> 等），则进行的是整数除法，结果将是一个整数，并且会<strong>向下取整</strong>（截断小数部分）。</p></li><li><p>在C语言中，<code>scanf(&quot;%s&quot;, str1)</code>用于从标准输入中读取一个字符串，并将其存储到字符数组<code>str1</code>中。然而，<code>scanf</code>函数<font color="red">在读取字符串后会在缓冲区中留下一个换行符（’\n’）</font>，这可能会导致后续的输入函数（如<code>fgets</code>或另一个<code>scanf</code>）出现问题。为了解决这个问题，可以在<code>scanf</code>之后添加一个<code>getchar()</code>函数调用，<strong>以读取并消耗掉缓冲区中的换行符</strong>。这样可以确保下一个输入函数从清空了缓冲区的状态开始读取。</p></li><li><p>大规模输入输出时，不要用cin和cout，否则时间真的会超限！</p></li><li><p>long long 和int不要混用！</p></li><li><p>mex(arr) 表示数组arr中末出现过的最小非负整数。例如[0,1,2,4]的mex为3。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mex</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(arr.begin(), arr.end())</span></span>;</span><br><span class="line">    <span class="type">int</span> mex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s.<span class="built_in">count</span>(mex)) mex++;</span><br><span class="line">    <span class="keyword">return</span> mex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li></li></ol><h2 id="Python快速入门"><a href="#Python快速入门" class="headerlink" title="Python快速入门"></a>Python快速入门</h2><ol><li><p>Python构建二维数组的方法：<code>[[0] * (n + 1) for _ in range(m + 1)]</code>，这样构建的二维数组，在修改任意元素时不会造成其他位置的元素被修改。</p></li><li><p>Python的排序函数：<code>sorted()</code>，可用于对任何可迭代对象（如列表、元组、字符串等）进行排序。<code>sorted()</code>返回排序后的新列表，不会改变原列表。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">sorted_numbers = <span class="built_in">sorted</span>(numbers)</span><br><span class="line"><span class="built_in">print</span>(sorted_numbers)  <span class="comment"># 输出：[1, 2, 5, 5, 6, 9]</span></span><br><span class="line"><span class="built_in">print</span>(numbers)         <span class="comment"># 输出：[5, 2, 9, 1, 5, 6]（原列表未改变）</span></span><br></pre></td></tr></table></figure></div><p>此外，<code>list.sort()</code>可以实现就地排序。</p><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">numbers.sort()</span><br><span class="line"><span class="built_in">print</span>(numbers)  <span class="comment"># 输出：[1, 2, 5, 5, 6, 9]</span></span><br></pre></td></tr></table></figure></div></li><li><p>Python获取子字符串只需要通过切片就行。字符串的拼接和复制也只需通过简单的数学运算符<code>+</code>和<code>*</code>实现。</p></li></ol><hr><h2 id="入门模拟"><a href="#入门模拟" class="headerlink" title="入门模拟"></a>入门模拟</h2><h3 id="日期计算"><a href="#日期计算" class="headerlink" title="日期计算"></a>日期计算</h3><p>有两个日期，求两个日期之间的天数，<strong>如果两个日期是连续的，则规定它们之间的天数为两天</strong>。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> date[<span class="number">2</span>][<span class="number">13</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;,&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLeap</span><span class="params">(<span class="type">int</span> year)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((year%<span class="number">4</span>==<span class="number">0</span>)&amp;&amp;(year%<span class="number">100</span>!=<span class="number">0</span>)) || (year%<span class="number">400</span>==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> time1,time2,y1,y2,m1,m2,d1,d2;</span><br><span class="line">  <span class="keyword">while</span>(cin&gt;&gt;time1&gt;&gt;time2)&#123;</span><br><span class="line">    <span class="keyword">if</span>(time1&gt;time2)&#123;<span class="type">int</span> tmp=time2;time2=time1;time1=time2;&#125;</span><br><span class="line">    <span class="comment">//需要前面的数字就用除，需要后面的数字就用模</span></span><br><span class="line">    y1=time1/<span class="number">10000</span>,m1=time1%<span class="number">10000</span>/<span class="number">100</span>,d1=time1%<span class="number">100</span>;</span><br><span class="line">    y2=time2/<span class="number">10000</span>,m2=time2%<span class="number">10000</span>/<span class="number">100</span>,d2=time2%<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y1&lt;y2 || m1&lt;m2 || d1&lt;d2)&#123;</span><br><span class="line">      d1++;</span><br><span class="line">      <span class="keyword">if</span>(d1==date[<span class="built_in">isLeap</span>(y1)][m1]+<span class="number">1</span>)&#123;m1++;d1=<span class="number">1</span>;&#125;</span><br><span class="line">      <span class="keyword">if</span>(m1==<span class="number">13</span>)&#123;y1++;m1=<span class="number">1</span>;&#125;</span><br><span class="line">      sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>由日期换算成星期时，也是需要用两日期的差值进行计算的。记1年1月1日为星期一，创建周期数组（注意第一个值为Sunday）：</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string week[<span class="number">7</span>]=&#123;<span class="string">&quot;Sunday&quot;</span>,<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>,<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p>两种非十进制需要借助十进制进行转换。如果涉及到小数，只能用字符串存储，然后根据整数部分<font color="orange">除基取余</font>和根据小数部分<font color="orange">乘基取整</font>完成运算。</p><p><img lazyload src="/images/loading.svg" data-src="https://ec28649.webp.li/20250301134944009.png" alt="image-20240511174603435"></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">char</span> alpha[<span class="number">6</span>]=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;<span class="type">char</span> n[<span class="number">80</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d&quot;</span>,&amp;a,n,&amp;b)!=EOF)&#123;</span><br><span class="line">        ll res_10=<span class="number">0</span>; <span class="type">int</span> len=<span class="built_in">strlen</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) res_10 = res_10*a + (n[i]&lt;=<span class="string">&#x27;9&#x27;</span>? n[i]-<span class="string">&#x27;0&#x27;</span>: n[i]&lt;=<span class="string">&#x27;F&#x27;</span>? n[i]-<span class="string">&#x27;A&#x27;</span>+<span class="number">10</span>: n[i]-<span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">10</span>) cout&lt;&lt;res_10&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">char</span> res_b[<span class="number">80</span>]; <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(res_b,<span class="number">0</span>,<span class="built_in">sizeof</span>(res_b));</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                res_b[cnt++]= res_10%b &lt;= <span class="number">9</span> ?res_10%b + <span class="string">&#x27;0&#x27;</span>: alpha[res_10%b<span class="number">-10</span>];</span><br><span class="line">                res_10/=b;</span><br><span class="line">            &#125;<span class="keyword">while</span>(res_10);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=cnt<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;res_b[i];</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(n,<span class="number">0</span>,<span class="built_in">sizeof</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><font color="red">当需要转换的是“大数”时，就应该仔细地去分析进制转换的具体实现细节！</font></p><p><img lazyload src="/images/loading.svg" data-src="https://ec28649.webp.li/20250301134959747.png" alt="image-20240512220414356"></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> str1[<span class="number">37</span>],str2[<span class="number">37</span>],str3[<span class="number">100010</span>];</span><br><span class="line"><span class="comment">//其中str1用来存储被除数，str2用来存储除数，str3用来存储二进制结果。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) <span class="keyword">if</span>(str[i]!=<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str1)!=EOF)&#123;</span><br><span class="line">        <span class="type">int</span> idx1=<span class="number">0</span>,idx2=<span class="number">0</span>,len=<span class="built_in">strlen</span>(str1);</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(idx1&lt;len)&#123;</span><br><span class="line">                num=num*<span class="number">10</span>+str1[idx1]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                str2[idx1++]=num/<span class="number">2</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                num%=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            str3[idx2++]=num + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++) <span class="keyword">if</span>(str2[i])&#123;idx1=i;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="built_in">memset</span>(str1,<span class="number">0</span>,<span class="built_in">sizeof</span>(str1));</span><br><span class="line">            <span class="built_in">strcpy</span>(str1, str2);  <span class="comment">//交换被除数和除数</span></span><br><span class="line">            <span class="built_in">memset</span>(str2,<span class="number">0</span>,<span class="built_in">sizeof</span>(str2));</span><br><span class="line">        &#125;<span class="keyword">while</span>(!<span class="built_in">isEmpty</span>(str1));</span><br><span class="line">        <span class="type">int</span> len1=<span class="built_in">strlen</span>(str3);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len1<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;str3[i];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">memset</span>(str3,<span class="number">0</span>,<span class="built_in">sizeof</span>(str3));</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>[!caution]</p><p>这段代码对10进制以下的进制都是通用的，只需要把最里层while循环中的两个‘2’换成所需要转换的进制数即可。</p><p>当然对于11-16进制，只需要再添加一个<code>char alpha[6]=&#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;&#125;;</code>这样的<code>aplha</code>转换表即可。</p></blockquote><h3 id="字符串转数值"><a href="#字符串转数值" class="headerlink" title="字符串转数值"></a>字符串转数值</h3><p>这是一类经典的题目，不要再单独写一个函数用来<code>str_to_int</code>了</p><p>“123456789”转成对应的数值其实相当方便：</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum=<span class="number">0</span>,len=<span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">  sum=sum*<span class="number">10</span>+str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure></div><p>而数值转字符串就更加方便了：</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num=<span class="number">123456789</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(str,<span class="string">&quot;%d&quot;</span>,num);</span><br></pre></td></tr></table></figure></div><h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><h4 id="质数的判定"><a href="#质数的判定" class="headerlink" title="质数的判定"></a>质数的判定</h4><p>时间复杂度为$O(\sqrt n)$</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="function">    if n&lt;<span class="number">2</span>: return False</span></span><br><span class="line"><span class="function">    i=</span><span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i*i &lt;=n:</span><br><span class="line">        <span class="keyword">if</span> n%i==<span class="number">0</span>: <span class="keyword">return</span> False</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> True</span><br></pre></td></tr></table></figure></div><h4 id="分解质因子"><a href="#分解质因子" class="headerlink" title="分解质因子"></a>分解质因子</h4><p>时间复杂度为$O(logn\sim \sqrt n)$</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++)&#123;</span><br><span class="line">      	<span class="keyword">if</span>(n%i==<span class="number">0</span>) &#123;</span><br><span class="line">          	<span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">          	<span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">              	n/=i; s++;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,i,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">if</span>(n&gt;<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">divide</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="function">    i=</span><span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i*i &lt;=n:</span><br><span class="line">        <span class="keyword">if</span> n%i==<span class="number">0</span>:</span><br><span class="line">            s=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n%i==<span class="number">0</span>:</span><br><span class="line">                n<span class="comment">//=i</span></span><br><span class="line">                s+=<span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(i,s)</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n&gt;<span class="number">1</span>: <span class="built_in">print</span>(n,<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div><h4 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h4><p>时间复杂度$O(nloglogn)$</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> primes[N],cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      	<span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">          	primes[cnt++]=n;</span><br><span class="line">          	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>*i;j&lt;=n;j+=i) st[j]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h4><p>时间复杂度$O(n)$，每个数只会被其最小质因子筛掉。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> primes[N],cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      	<span class="keyword">if</span>(!st[i]) primes[cnt++]=i;</span><br><span class="line">      	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;primes[j]&lt;=n/i;j++)&#123;</span><br><span class="line">          	st[primes[j]*i]=<span class="literal">true</span>;</span><br><span class="line">          	<span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><h4 id="分解约数"><a href="#分解约数" class="headerlink" title="分解约数"></a>分解约数</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  	vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n/i;i++)&#123;</span><br><span class="line">      	<span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">          	res.<span class="built_in">push_back</span>(i);</span><br><span class="line">          	<span class="keyword">if</span>(i!=n/i) res.<span class="built_in">push_back</span>(n/i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">  	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h4><h4 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h4><h4 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b,a%b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="算法初步"><a href="#算法初步" class="headerlink" title="算法初步"></a>算法初步</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序通过多次<font color="red">比较和交换相邻元素</font>的方式将待排序的数据按照升序或降序进行排序。时间复杂度：$O(n^2)$。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;<span class="type">int</span> tmp=arr[j];arr[j]=arr[j+<span class="number">1</span>];arr[j+<span class="number">1</span>]=tmp;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序将待排序的数据序列分为已排序部分和未排序部分，每次<font color="red">从未排序部分选择最小（或最大）的元素，将其放置在已排序部分的末尾</font>，直到整个序列排序完成。时间复杂度：$O(n^2)$。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> idx=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=idx+<span class="number">1</span>;j&lt;len;j++) <span class="keyword">if</span>(arr[j]&lt;arr[idx]) idx=j;</span><br><span class="line">        <span class="type">int</span> tmp=arr[idx]; arr[idx]=arr[i]; arr[i]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>插入排序将待排序的数据序列分为已排序部分和未排序部分，每次从<font color="red">未排序部分选择一个元素插入到已排序部分的合适位置</font>，直到整个序列排序完成。时间复杂度：$O(n^2)$。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx&lt;= i)&#123;<span class="keyword">if</span>(arr[i]&lt;arr[idx])&#123;<span class="type">int</span> tmp=arr[i];arr[i]=arr[idx];arr[idx]=tmp;&#125;idx++;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序（Shell Sort）是一种基于插入排序的排序算法，旨在提高插入排序在大规模数据集上的效率。它通过比较距离较远的元素来进行排序，从而减少了数据移动的次数。</p><ol><li><strong>分组排序</strong>：<ul><li>将整个待排序的数组按照一定的增量（gap）分成若干个子序列，对每个子序列分别进行插入排序。</li><li>初始的增量较大，随着算法的进行逐渐减小，直到增量为1，此时整个数组被当作一个子序列进行插入排序。</li></ul></li><li><strong>增量序列</strong>：<ul><li>增量序列的选择对希尔排序的性能有很大影响。常用的增量序列有希尔增量（gap &#x3D; n&#x2F;2, n&#x2F;4, …, 1）、Hibbard增量（1, 3, 7, 15, …）等。</li><li>理想的增量序列可以减少比较次数和移动次数，从而提高排序效率。</li></ul></li><li><strong>排序过程</strong>：<ul><li>初始时选择一个较大的增量，将数组元素分组。</li><li>对每个分组内的元素进行插入排序。</li><li>减小增量，重复上述步骤，直到增量为1。</li></ul></li></ol><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序是通过<strong>分治的策略</strong>将一个大问题分解为多个子问题，然后逐步解决子问题，最终达到整体问题的解决。</p><p>快速排序的基本思想可以概括为以下几个步骤：</p><ol><li>选择一个基准元素：从待排序的数组中<strong>选择一个元素作为基准</strong>，通常选择第一个元素、最后一个元素或者随机选取。</li><li>分区：将数组中的其他元素按照与基准元素的大小关系分为两个子数组，<strong>一个子数组中的元素小于基准元素，另一个子数组中的元素大于基准元素</strong>。同时，<strong>基准元素所在的位置也确定了</strong>。</li><li>递归排序：对分区后的两个子数组<strong>递归</strong>地应用上述步骤，直到子数组的大小为1或0（即已经有序）。</li><li>合并结果：将所有子数组的结果合并起来，即得到最终的有序数组。</li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;  <span class="comment">//递归出口</span></span><br><span class="line">    <span class="type">int</span> num=arr[l],front=l<span class="number">-1</span>,rear=r+<span class="number">1</span>; <span class="comment">//注意前后两指针的初始位置</span></span><br><span class="line">    <span class="keyword">while</span>(front&lt;rear)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[++front]&lt;num);</span><br><span class="line">        <span class="keyword">while</span>(arr[--rear]&gt;num);</span><br><span class="line">        <span class="keyword">if</span>(front&lt;rear) <span class="built_in">swap</span>(arr[front],arr[rear]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr,l,rear);</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr,rear+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>[!IMPORTANT]</p><p>从快排中抽离出来的一个双指针的思想</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(front&lt;rear)&#123;</span><br><span class="line">		<span class="keyword">while</span>(Condition1) Action1; </span><br><span class="line">		<span class="keyword">while</span>(Condition2) Action2;</span><br><span class="line">		Action3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><code>Condition1</code>用来确定<strong>左指针</strong>在一轮循环中什么时候停止，<code>Action1</code>是遍历<strong>左端序列</strong>时需要做的行为；</li><li><code>Condition2</code>用来确定<strong>右指针</strong>在一轮循环中什么时候停止，<code>Action2</code>是遍历<strong>右端序列</strong>时需要做的行为；</li><li><code>Action3</code>是完成一轮循环后需要执行的动作。</li></ul></blockquote><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序是一种经典的、<strong>稳定</strong>的排序算法，其基本思想是将一个大问题分解为多个小问题，通过递归地将小问题排序并合并，最终得到整体问题的解决。</p><p>归并排序的基本思想可以概括为以下几个步骤：</p><ol><li>分解：将待排序的数组递归地分解为较小的子数组，直到每个子数组只包含一个元素（即已经有序）或为空。</li><li>合并：将分解得到的子数组逐个合并，得到更大的有序子数组。<strong>合并过程是通过比较每个子数组的元素，选取最小（或最大）的元素放入新的数组中，并移动相应的指针</strong>。</li><li>递归排序和合并：重复执行步骤1和步骤2，直到所有的子数组合并为一个完整的有序数组。</li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(arr,l,mid);</span><br><span class="line">    <span class="built_in">MergeSort</span>(arr,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="type">int</span> idx=<span class="number">0</span>, idx1=l,idx2=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> tmp[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">while</span>(idx1&lt;=mid &amp;&amp; idx2&lt;=r)</span><br><span class="line">        <span class="keyword">if</span>(arr[idx1]&lt;arr[idx2]) tmp[idx++]=arr[idx1++];</span><br><span class="line">        <span class="keyword">else</span> tmp[idx++]=arr[idx2++];</span><br><span class="line">    <span class="keyword">while</span>(idx1&lt;=mid) tmp[idx++]=arr[idx1++];</span><br><span class="line">    <span class="keyword">while</span>(idx2&lt;=r) tmp[idx++]=arr[idx2++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) arr[i]=tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>[!IMPORTANT]</p><p>从归并排序中抽离出来的一个双指针的思想，也就是说双路归并使用双指针即可。</p><p>假如是多路归并呢？想想数据结构这门课中所学的赢者树和败者树，其本质都是堆。<strong>因此多路归并完全可以用堆（优先队列）进行优化。</strong></p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(idx1&lt;len1 &amp;&amp; idx2&lt;len2)&#123;</span><br><span class="line">   		<span class="keyword">if</span>(Condition1) Action1;</span><br><span class="line">   		<span class="keyword">else</span> Action2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(Condition2) Action3;</span><br><span class="line"><span class="keyword">while</span>(Condition3) Action4;</span><br></pre></td></tr></table></figure></div><ul><li><code>Condition1</code>是两个数组进行比较的条件，<code>Action1</code>是对应条件为真执行的动作，<code>Action2</code>是对应条件为假执行的动作。</li><li><code>Condition2</code>是对<strong>数组1</strong>进行的扫尾条件判断，<code>Action3</code>是对应的扫尾动作；</li><li><code>Condition3</code>是对<strong>数组2</strong>进行的扫尾条件判断，<code>Action4</code>是对应的扫尾动作；</li></ul><p>OJ例题：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/">寻找两个正序数组的中位数 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h4 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a>sort函数</h4><p>在OJ的题目中，一般不会手动写排序函数，可以直接调用C++的sort函数进行排序！其中，最关键的点就是排序规则的定义。默认情况下是升序排序，可以通过在第三个参数填入<code>greater&lt;int&gt;()</code>来实现降序排序，而且是针对一般的整数数组。要自定义排序规则，则需要实现一个自定义的比较函数<code>bool cmp()</code>。</p><blockquote><p>[!Note]</p><p>如学生类比较函数的规则：先按分数升序排序，相同按名字字母序排序。</p></blockquote><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Student s1, Student s2)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(s1.score != s2.score) <span class="keyword">return</span> s1.score &gt; s2.score;</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">strcmp</span>(s1.name,s2.name) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/tag/binary-search/problemset/">二分 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><p><strong>二分通过不断将搜索范围减半来快速定位目标元素</strong>。</p><blockquote><p>[!CAUTION]</p><p><strong>二分的主要思想不是单调性</strong>（当然序列满足单调性一定能二分做），而是<strong>能否根据某一性质划分为左右两个区间</strong>！</p><p><strong>每进行一次二分就是把答案所在的区间给缩小，因此需要准确地判断出答案应该在哪个区间</strong>！当区间的长度为1时，那么该区间中的元素就是答案！</p></blockquote><h4 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h4><p>无论是<code>l+r&gt;&gt;1</code>还是<code>l+r+1&gt;&gt;1</code>都是为了数组元素个数为奇时，处理好边界问题。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_l</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;  <span class="comment">//找左边边界</span></span><br><span class="line">		<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">      	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">      	<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid; <span class="comment">//这个check函数需要严格考虑边界情况，以及方向是否正确</span></span><br><span class="line">      	<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">return</span> l; <span class="comment">//这里无论返回是l还是r都是一样的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_r</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;  <span class="comment">//找右边边界</span></span><br><span class="line">		<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">      	<span class="type">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">      	<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid;</span><br><span class="line">      	<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>[!Tip]</p><p>主要通过check函数判断应该递归哪个区间来判断使用哪个模板。<strong>二分找不到元素的情况是下标l对应的元素不等于需要查找的元素！</strong></p></blockquote><h5 id="单调性二分"><a href="#单调性二分" class="headerlink" title="单调性二分"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/description/">单调性二分 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;=target) r=mid; <span class="comment">//需要严格注意边界和区间</span></span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[l]!=target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="特性二分"><a href="#特性二分" class="headerlink" title="特性二分"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">特性二分 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h5><blockquote><p>这个题目典型就是根据旋转之后，<strong>根据哪一边是有序的这一特性进行二分的</strong>。</p></blockquote><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="comment">// 判断哪一半是有序的</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt;= nums[mid])<span class="comment">// 左半部分是有序的</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) </span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">// 目标值在左半部分</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 目标值在右半部分</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 右半部分是有序的</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) </span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 目标值在右半部分</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">// 目标值在左半部分</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="非指针二分"><a href="#非指针二分" class="headerlink" title="非指针二分"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">非指针二分 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h5><blockquote><p>[!Note]</p><p>这里的非指针二分其实也是特性二分中的一种，只是这种二分更加抽象，以至于连<code>left</code>和<code>right</code>都不再只是表示区间两端的指针。</p><p>如这个题目中的，假设把<code>left</code>定义成子区间长度的下限，而<code>right</code>定义为子区间长度的上限，那么问题就变成，求解一个最小的区间长度，使得<code>check</code>满足条件。</p></blockquote><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断长度为mid的子数组和是否能够大于等于target</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOver</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; sum, <span class="type">int</span> mid, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = sum.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>((sum[i]-sum[i-mid])&gt;=target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];  <span class="comment">//前缀和</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = n;  <span class="comment">//子数组的长度范围为闭区间[1, n]</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;  <span class="comment">//二分查找</span></span><br><span class="line">        <span class="type">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isOver</span>(sum, mid, target)) left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left==n+<span class="number">1</span> ? <span class="number">0</span> : left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="左右边界不一致"><a href="#左右边界不一致" class="headerlink" title="左右边界不一致"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">左右边界不一致 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h5><blockquote><p>[!NOTE]</p><p>在前面的举例中，无一例外都是左右边界一直的情况，所以无论是<code>bsearch_l</code>还是<code>bsearch_r</code>都能完成任务。但是一旦当左右边界不一致时，<code>bsearch_l</code>所求的是左边界，而<code>bsearch_r</code>所求的是右边界。</p></blockquote><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;=target) l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> right=l;</span><br><span class="line">    l=<span class="number">0</span>;r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;=target) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="type">int</span> left=l;</span><br><span class="line">    <span class="keyword">if</span>(target==nums[left]) <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;left,right&#125;;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="浮点二分"><a href="#浮点二分" class="headerlink" title="浮点二分"></a>浮点二分</h4><p>浮点二分常见于一些求实根的题目中。eg. xmu2024年人工智能实验室夏令营机式的第一题就是利用浮点二分求实根！需要额外注意的就是<code>eps</code>的精度问题，一般需要比保留的位数多两位。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">double</span> l,<span class="type">double</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(r-l&gt;eps)&#123;</span><br><span class="line">      	<span class="type">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">      	<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;  </span><br><span class="line">      	<span class="keyword">else</span> l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当然，如果<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/submissions/557190365/">一些题目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>只需要保留整数部分，那么也是可以用整数二分去求解的。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = x;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> p = <span class="number">1.0</span> * mid * mid;</span><br><span class="line">        <span class="keyword">if</span>(p == x) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p &lt; x) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="大数运算"><a href="#大数运算" class="headerlink" title="大数运算"></a>大数运算</h3><p><strong>注意大数在数组中的存储顺序：从低位存储到高位。</strong></p><h4 id="大数加"><a href="#大数加" class="headerlink" title="大数加"></a>大数加</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>()||i&lt;b.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;a.<span class="built_in">size</span>()) sum+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;b.<span class="built_in">size</span>()) sum+=b[i];</span><br><span class="line">        res.<span class="built_in">push_back</span>(sum%<span class="number">10</span>);</span><br><span class="line">        sum/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum) res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a,b; vector&lt;<span class="type">int</span>&gt; A,B;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">auto</span> res= <span class="built_in">add</span>(A,B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=res.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;res[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="大数减"><a href="#大数减" class="headerlink" title="大数减"></a>大数减</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a,<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()!=b.<span class="built_in">size</span>()) <span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(a[i]!=b[i]) <span class="keyword">return</span> a[i]&gt;b[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;b.<span class="built_in">size</span>()) sum-=b[i];</span><br><span class="line">        res.<span class="built_in">push_back</span>((sum+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) sum=<span class="number">-1</span>;  <span class="comment">//借位与否</span></span><br><span class="line">        <span class="keyword">else</span> sum=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(res.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; res.<span class="built_in">back</span>()==<span class="number">0</span>) res.<span class="built_in">pop_back</span>();  <span class="comment">//去掉前导0</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a,b;vector&lt;<span class="type">int</span>&gt; A,B;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(A,B)) &#123;res=<span class="built_in">sub</span>(A,B); <span class="keyword">for</span>(<span class="type">int</span> i=res.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;res[i];&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;res=<span class="built_in">sub</span>(B,A); cout&lt;&lt;<span class="string">&quot;-&quot;</span>; <span class="keyword">for</span>(<span class="type">int</span> i=res.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;res[i];&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="大数乘"><a href="#大数乘" class="headerlink" title="大数乘"></a>大数乘</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>() || sum;i++)&#123;</span><br><span class="line">        sum+=a[i]*b;</span><br><span class="line">        res.<span class="built_in">push_back</span>(sum%<span class="number">10</span>);</span><br><span class="line">        sum/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="大数除"><a href="#大数除" class="headerlink" title="大数除"></a>大数除</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a,<span class="type">int</span> b，<span class="type">int</span> &amp;c)</span></span>&#123;  <span class="comment">//c是余数</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res; <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        sum=sum*<span class="number">10</span>+a[i];</span><br><span class="line">        res.<span class="built_in">push_back</span>(sum/b);</span><br><span class="line">        sum%=b;</span><br><span class="line">    &#125;</span><br><span class="line">  	c=sum; <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span>(res.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; res.<span class="built_in">back</span>()== <span class="number">0</span>) res.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="整数哈希"><a href="#整数哈希" class="headerlink" title="整数哈希"></a>整数哈希</h4><p>整数哈希的作用是将<strong>数据范围较大的值域转换到范围较小的值域空间</strong>。其中避免哈希冲突的方案有拉链法和开放地址法。</p><p><strong>原数据大且稀疏，转到到小且稠密的空间上</strong>。</p><p><strong>除了数据空间的映射之外，哈希还可能应用到一些在集合以$O(1)$时间复杂度去判断元素是否存在的场景。</strong></p><h5 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">3</span>;  <span class="comment">// N一定要是素数且大于数据范围</span></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx; <span class="comment">// 其中h是指针数组，e存储节点，ne存储指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">  	<span class="built_in">memset</span>(ne,<span class="number">-1</span>,<span class="keyword">sizeof</span> ne);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  	<span class="type">int</span> k=(x%N+N)%N;</span><br><span class="line">  	e[idx]=x;ne[idx]=h[k];h[k]=idx++; <span class="comment">// 这三句是头插法实现，如果用尾插法不要直接循环找末尾元素，可以增加一个尾指针。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  	<span class="type">int</span> k=(x%N+N)%N;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=h[k];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">      	<span class="keyword">if</span>(e[i]==x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">100003</span>  # N 是素数且大于数据范围</span><br><span class="line">h, e, ne, idx = [<span class="number">-1</span>]*N, [<span class="number">0</span>]*N, [<span class="number">-1</span>]*N, <span class="number">0</span>     </span><br><span class="line"></span><br><span class="line">def <span class="built_in">init</span>():</span><br><span class="line">    global h, ne, idx</span><br><span class="line">    h = [<span class="number">-1</span>] * N</span><br><span class="line">    ne = [<span class="number">-1</span>] * N</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">def <span class="built_in">insert</span>(x):</span><br><span class="line">    global idx</span><br><span class="line">    k = (x % N + N) % N  # 处理负数取模</span><br><span class="line">    e[idx] = x</span><br><span class="line">    ne[idx] = h[k]</span><br><span class="line">    h[k] = idx</span><br><span class="line">    idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">def <span class="built_in">find</span>(x):</span><br><span class="line">    k = (x % N + N) % N  # 处理负数取模</span><br><span class="line">    i = h[k]</span><br><span class="line">    <span class="keyword">while</span> i != <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">if</span> e[i] == x:</span><br><span class="line">            <span class="keyword">return</span> True</span><br><span class="line">        i = ne[i]</span><br><span class="line">    <span class="keyword">return</span> False</span><br></pre></td></tr></table></figure></div><p>经典例题：<a class="link" target="_blank" rel="noopener" href="https://acm.swust.edu.cn/#/problem/1012/-1">1012.哈希表（链地址法处理冲突） - Problems | SWUST OJ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> m,n,idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> h[],<span class="type">int</span> e[],<span class="type">int</span> ne[],<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=(c%m+m)%m;</span><br><span class="line">    <span class="type">int</span> i=h[k];</span><br><span class="line">    <span class="keyword">while</span>(i!=<span class="number">-1</span> &amp;&amp; ne[i]!=<span class="number">-1</span>) i=ne[i];</span><br><span class="line">    e[idx]=c;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">-1</span>) &#123;h[k]=idx++;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;ne[i]=idx++;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PII <span class="title">find</span><span class="params">(<span class="type">int</span> h[],<span class="type">int</span> e[],<span class="type">int</span> ne[],<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=(c%m+m)%m;<span class="type">int</span> i=h[k];<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i!=<span class="number">-1</span>)&#123;</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">if</span>(e[i]==c) <span class="keyword">return</span> <span class="built_in">make_pair</span>(k,sum);</span><br><span class="line">        i=ne[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(k,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> h[m],e[m],ne[m],num;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(ne,<span class="number">-1</span>,<span class="keyword">sizeof</span> ne);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        cin&gt;&gt;num;</span><br><span class="line">        <span class="built_in">insert</span>(h,e,ne,num);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;num;</span><br><span class="line">    PII res=<span class="built_in">find</span>(h,e,ne,num);</span><br><span class="line">    <span class="keyword">if</span>(res.second!=<span class="number">-1</span>) cout&lt;&lt;res.first&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;res.second;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">3</span>;   <span class="comment">//这个N需要是大于2到3倍数据范围的一个最小质数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;  <span class="comment">//约定改数表示位置无数据存储</span></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="built_in">memset</span>(h,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置。因此find的返回值还需要再进行一次if判断。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  	<span class="type">int</span> k=(x%N+N)%N;</span><br><span class="line">  	<span class="keyword">while</span>(h[k]!=INF &amp;&amp; h[k]!=x)&#123;</span><br><span class="line">      	k++;</span><br><span class="line">      	<span class="keyword">if</span>(k==N) k=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h6 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/submissions/558717961/">最长连续序列 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h6><p>也就是说是可以自己实现C++ STL容器<code>unordered_set</code>。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> maxn=<span class="number">2e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> h[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=(x%maxn+maxn)%maxn;</span><br><span class="line">    <span class="keyword">while</span>(h[k]!=INF &amp;&amp; h[k]!=x)&#123;</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span>(k==maxn) k=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:nums)&#123;</span><br><span class="line">        <span class="type">int</span> idx=<span class="built_in">find</span>(item);</span><br><span class="line">        <span class="keyword">if</span>(h[idx]==INF) h[idx]=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item :nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h[<span class="built_in">find</span>(item<span class="number">-1</span>)]==INF)&#123;</span><br><span class="line">            <span class="type">int</span> curnum=item;</span><br><span class="line">            <span class="type">int</span> curlen=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(h[<span class="built_in">find</span>(curnum+<span class="number">1</span>)]!=INF)&#123;curlen++;curnum++;&#125;</span><br><span class="line">            res=<span class="built_in">max</span>(res,curlen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h4><p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低<br>小技巧：<strong>取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</strong></p><p><strong>可以用来快速判断区间字符串是否一致。</strong></p><p><font color="red"><strong>字符串下标必须从1开始，可以更好地处理边界问题</strong></font>。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;  <span class="comment">//用unsigned long long存储就避免了取模运算</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P=<span class="number">131</span>; <span class="comment">// P的经验值是131或13331</span></span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(string str)</span></span>&#123;  <span class="comment">//这个字符串需保证下标从1开始</span></span><br><span class="line">  	p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">strHash</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];  <span class="comment">// r-l+1是这两个位数之间差的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h3><p>前缀和的作用：能够快速求出原数组中<strong>一段的和</strong>。前缀和数组还有个最基本的性质，就是单调递增的。</p><p>差分的作用：可以用于<strong>处理区间修改和查询操作</strong>。<strong>通过对差分数组进行修改，可以在常数时间内更新原始序列的某个区间</strong>。这对于需要频繁修改某个区间的问题非常有用，如区间加法、区间减法等。</p><blockquote><p>[!TIP]</p><p><font color="red"><strong>数组下标必须从1开始，可以更好地处理边界问题</strong></font>。</p></blockquote><p><img lazyload src="/images/loading.svg" data-src="https://ec28649.webp.li/20250301134853477.png" alt="加粗样式"></p><p><img lazyload src="/images/loading.svg" data-src="https://ec28649.webp.li/20250301135049003.png" alt="在这里插入图片描述"></p><h4 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h4><p>一维前缀和数组：<code>sum[i] = sum[i - 1] + arr[i]</code>;</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> size=<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> sum[size];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= size; i++)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + arr[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h4><p>二维前缀和数组：<code>sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + arr[i][j]</code>;</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x_size = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y_size = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> sum[y_size][x_size];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= y_size; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= x_size; j++)</span><br><span class="line">            sum[i][j] = sum[i][j - <span class="number">1</span>] + sum[i - <span class="number">1</span>][j] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + arr[i][j];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h4><p>一维差分数组：<code>dif[i] = arr[i] - arr[i - 1]</code></p><p>对差分数组进行前缀和运算可以获得原数组，但局限于<strong>多次操作单次(少次)还原</strong></p><p>一维差分运算：</p><p><code>arr[L,R]+value</code></p><p>等价于</p><p><code>dif[L]+value,</code></p><p><code>dif[R+1]-value</code></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> size=<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> dif[size];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= size; i++)</span><br><span class="line">        dif[i] = arr[i] - arr[i - <span class="number">1</span>];	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N],dif[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    dif[l]+=c;</span><br><span class="line">    dif[r+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">insert</span>(i,i,arr[i]);  <span class="comment">//这就是在初始化差分数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r,c; cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        <span class="built_in">insert</span>(l,r,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) arr[i]=arr[i<span class="number">-1</span>]+dif[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;arr[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h4><p>二维差分数组：<code>dif[i][j]=arr[i][j]-arr[i-1][j]-arr[i][j-1]+arr[i-1][j-1]</code></p><p>二维差分运算：</p><p><code>arr[x1,x2][y1,y2]+value</code></p><p>等价于</p><p><code>dif[x1][y1]+value,</code></p><p><code>dif[x1+1][y1]-value,</code></p><p><code>dif[x1][y1+1]-value,</code></p><p><code>dif[x1+1][y1+1]+value</code></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x_size = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y_size = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> dif[y_size][x_size];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= y_size; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= x_size; j++)</span><br><span class="line">            dif[i][j] = arr[i][j] - arr[i][j - <span class="number">1</span>] - arr[i - <span class="number">1</span>][j] + arr[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N][N],diff[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    diff[x1][y1]+=c; diff[x1][y2+<span class="number">1</span>]-=c; diff[x2+<span class="number">1</span>][y1]-=c; diff[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,k;cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) cin&gt;&gt;arr[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">insert</span>(i,j,i,j,arr[i][j]);  <span class="comment">//初始化dif数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;k;t++) &#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2,num; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;num; <span class="built_in">insert</span>(x1,y1,x2,y2,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) arr[i][j]=arr[i<span class="number">-1</span>][j]+arr[i][j<span class="number">-1</span>]-arr[i<span class="number">-1</span>][j<span class="number">-1</span>]+diff[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) cout&lt;&lt;arr[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>; cout&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/tag/two-pointers/problemset/">双指针 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><p>双指针将$O(n^2)$的算法优化到$O(n)$ 。</p><p><strong>双指针最重要的是找到某一种方案去更新两个指针</strong>。</p><p>双指针可以是从两端往中间靠（大部分情况），也可以是从中间往两端靠（eg. 最长回文子串），也可是同时从一边以不同速度走（大部分情况，eg. KMP算法、链表一趟遍历的删插操作），也可以是作用在不同的序列上（eg. 归并排序中的合并操作）。</p><h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文子串 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h4><blockquote><p>[!TIP]</p><p>首先确定回文串，找中心然后想两边扩散看是不是对称的就可以了。</p><p><strong>一个元素可以作为中心点，两个元素也可以作为中心点</strong>。</p></blockquote><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxL=<span class="number">0</span>,left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">const</span> string&amp; s,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;n &amp;&amp;s[i]==s[j])&#123;</span><br><span class="line">        <span class="keyword">if</span>(j-i+<span class="number">1</span>&gt;maxL)&#123;left=i,right=j,maxL=j-i+<span class="number">1</span>;&#125;</span><br><span class="line">        i--;j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="built_in">extend</span>(s,i,i,s.<span class="built_in">size</span>());  <span class="comment">//一个元素为中心点</span></span><br><span class="line">        <span class="built_in">extend</span>(s,i,i+<span class="number">1</span>,s.<span class="built_in">size</span>());  <span class="comment">//两个元素为中心点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">substr</span>(left,maxL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/description/">盛最多水的容器 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = height.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=len<span class="number">-1</span>,maxA=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">if</span>((j-i)*<span class="built_in">min</span>(height[i],height[j])&gt;maxA)</span><br><span class="line">            maxA=(j-i)*<span class="built_in">min</span>(height[i],height[j]);</span><br><span class="line">        <span class="keyword">if</span>(height[i]&gt;height[j]) j--; <span class="comment">//移动短板</span></span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/">三数之和 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> len =nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); <span class="comment">//进行排序是为了后面双指针进行双向更新提供条件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">//防止遍历的i出现重复</span></span><br><span class="line">        <span class="type">int</span> l=i+<span class="number">1</span>,r=len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]+nums[r]==-nums[i]) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;nums[i],nums[l++],nums[r]&#125;); </span><br><span class="line">                <span class="keyword">while</span>(nums[l<span class="number">-1</span>]==nums[l] &amp;&amp; l&lt;r) l++; <span class="comment">//防止双指针出现重复元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[l]+nums[r]&gt;-nums[i]) r--;</span><br><span class="line">            <span class="keyword">else</span> l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>求n的2进制的第k位数字：<code>n&gt;&gt;k &amp; 1</code></p><p>提取一个整数 <code>n</code> 的二进制表示中最低位的 1 所代表的值：<code>lowbit(n)=n &amp; -n</code></p><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>离散化的本质是建立了一段数列到自然数之间的映射关系（value -&gt; index)，通过建立新索引，来缩小目标区间，使得可以进行一系列连续数组可以进行的操作。eg：二分，前缀和等</p><blockquote><p>[!caution]</p><p>离散化首先需要<strong>排序去重</strong>！</p></blockquote><p>排序：<code>sort(alls.begin(),alls.end())</code><br>去重：<code>alls.earse(unique(alls.begin(),alls.end()),alls.end())</code></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="comment">// 找到第一个大于等于x的位置</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a><a class="link" target="_blank" rel="noopener" href="https://ykj.cpolar.cn/problem/6588">区间和 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> arr[N], sum[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; odd;</span><br><span class="line">vector&lt;PII&gt; add, query;</span><br><span class="line"></span><br><span class="line"><span class="comment">//value-&gt;key的映射函数(通过二分实现)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = odd.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = len;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (odd[mid] &gt;= x)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//读入数据，并将需要离散化的数据添加到odd中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(x, c));</span><br><span class="line">        odd.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(l, r));</span><br><span class="line">        odd.<span class="built_in">push_back</span>(l);</span><br><span class="line">        odd.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序与去重，为了使用二分查找建立值到键的索引</span></span><br><span class="line">    <span class="built_in">sort</span>(odd.<span class="built_in">begin</span>(), odd.<span class="built_in">end</span>());</span><br><span class="line">    odd.<span class="built_in">erase</span>(<span class="built_in">unique</span>(odd.<span class="built_in">begin</span>(), odd.<span class="built_in">end</span>()), odd.<span class="built_in">end</span>());</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">//将对原数的操作映射到对离散后数值的操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : add) &#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">find</span>(item.first);</span><br><span class="line">        arr[idx] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//建立前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= odd.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        sum[i] += sum[i - <span class="number">1</span>] + arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">   	<span class="comment">//利用前缀和求区间和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">find</span>(query[i].first), r = <span class="built_in">find</span>(query[i].second);</span><br><span class="line">        cout &lt;&lt; sum[r] - sum[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a><a class="link" href="hook://file/fmu9032lv?p=UmVzb3VyY2VzL3ZpZGVvcw==&n=%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6%2Emov">区间合并 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><p>首先需要将所有的区间根据<strong>其左区间的值进行升序排序；然后遍历每一个区间进行合并；遍历期间需要维护一个用于合并的区间</strong>。</p><p><img lazyload src="/images/loading.svg" data-src="https://ec28649.webp.li/20250301135101578.png" alt="image-20240821213440340"></p><p>对于待合并的区间，只可能与维护的区间有三种可能性：</p><ol><li><p>待合并区间完全包括在维护的区间中</p><p><strong>无需更新维护区间</strong></p></li><li><p>待合并区间与维护的区间有部分交集（且只可能是<code>End</code>端不在维护的区间中）</p><p>**将维护区间的<code>End</code>换成待合并区间的<code>End</code>**。</p></li><li><p>待合并区间与维护的区间完全无交集</p><p><strong>当前维护的区间可以纳入答案中，将该待合并的区间作为新的维护区间</strong>。</p></li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span>&#123; <span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());  <span class="comment">//默认以左区间进行排序</span></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;  <span class="comment">// 设置区间的边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)&#123;  <span class="comment">// 新的区间与维护的区间无交集</span></span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second); </span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a><a class="link" href="hook://file/fpfh2fI1G?p=UmVzb3VyY2VzL3ZpZGVvcw==&n=KMP%2Emov">KMP算法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><p>KMP算法用来解决子串与父串进行匹配的问题，可以将时间复杂度为$O(n^2)$的暴力匹配变成时间复杂度为$O(n+m)$。KMP算法的核心思想是<strong>利用已经匹配的信息来避免重复匹配，从而提高匹配效率</strong>。next数组记录了模式字符串中<strong>每个位置的前缀和后缀的最长公共部分的长度</strong>（最长相同前后缀or模式串匹配失败后应该重新开始匹配的位置）。</p><p><strong>特别需要注意的是：主串和模板串都从第一个位置开始存储。</strong></p><p><a class="link" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AY4y157yL/">手算next数组 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> str1[N],str2[M];</span><br><span class="line"><span class="type">int</span> ne[M];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=m;i++)&#123; <span class="comment">//从模式字符串的第二个字符开始遍历（因为部分匹配表的第一个值总是0）</span></span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; str2[i]!=str2[j+<span class="number">1</span>]) j=ne[j]; <span class="comment">//如果当前字符和前缀字符不匹配，并且j不为0，则回溯到前一个部分匹配的位置</span></span><br><span class="line">        <span class="keyword">if</span>(str2[i]==str2[j+<span class="number">1</span>]) j++; <span class="comment">//如果当前字符和前缀字符匹配，则j加1</span></span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; str1[i]!=str2[j+<span class="number">1</span>]) j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(str1[i]==str2[j+<span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j==m)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-m);</span><br><span class="line">            j=ne[j];  <span class="comment">//子串完全匹配后，下一个字符肯定不再相等，因此j需要重新回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;str1+<span class="number">1</span>&gt;&gt;m&gt;&gt;str2+<span class="number">1</span>;  <span class="comment">//两个字符数组下标从1开始存储</span></span><br><span class="line">    <span class="built_in">get_next</span>();</span><br><span class="line">    <span class="built_in">kmp</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="最短回文串"><a href="#最短回文串" class="headerlink" title="最短回文串"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-palindrome/">最短回文串 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h4><p>理解KMP算法的关键一步是理解next数组的含义，即<strong>字符串中每个位置的最长相等前后缀的长度</strong>，这种特性能很好地与回文串结合。</p><p>将任意串<code>baacbca</code>翻转再拼接原串<code>acbcaabbaacbca</code>的next数组为<code>00001100112345</code>，很有意思的是<strong>next数组的最后一个值就是原串中存在的一个最长回文串<code>[arr.end()-5+1,arr.end()]</code>的长度。</strong>假若需要将原串在一个方向添加字符拼凑成新的回文串，则只需在原串的末尾拼凑上原串<code>[arr.begin(),arr.begin()+arr.size()-5]</code>的字符即可。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">shortestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> ne[maxn];</span><br><span class="line">    string s1=<span class="string">&quot; &quot;</span>+s+<span class="string">&quot; &quot;</span>+<span class="built_in">string</span>(s.<span class="built_in">rbegin</span>(),s.<span class="built_in">rend</span>());  <span class="comment">//第一个空格是为了next数组计算，第二个空格是防止原串全为相同字符，导致回文串长度超过原串长度</span></span><br><span class="line">    <span class="type">int</span> len=s1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,i=<span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s1[i]!=s1[j+<span class="number">1</span>]) j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s1[i]==s1[j+<span class="number">1</span>]) j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    string s2=s.<span class="built_in">substr</span>(<span class="number">0</span>,ne[len<span class="number">-1</span>]);</span><br><span class="line">    string s3=s.<span class="built_in">substr</span>(ne[len<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(s3.<span class="built_in">rbegin</span>(),s3.<span class="built_in">rend</span>())+s2+s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/description/">重复的子字符串 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h4><p>KMP算法在应用层面最重要的就是场景识别，即在具体问题中能够抽象出使用KMP算法的场景，即模式串匹配。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> maxn=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> ne[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getnext</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,i=<span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i]!=s[j+<span class="number">1</span>]) j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>]) j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string ss=s+s;</span><br><span class="line">    <span class="type">int</span> len = ss.<span class="built_in">size</span>();</span><br><span class="line">    s=<span class="string">&quot; &quot;</span>+s;</span><br><span class="line">    <span class="built_in">getnext</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; ss[i]!=s[j+<span class="number">1</span>]) j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(ss[i]==s[j+<span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j==s.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h4><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><h4 id="集合系列"><a href="#集合系列" class="headerlink" title="集合系列"></a>集合系列</h4><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><ul><li>底层结构：set底层是由红黑树实现（红黑树是一种平衡二叉树），存储空间不连续；</li><li>访问遍历：不支持随机访问迭代器，不能通过下标直接访问，支持按顺序迭代，迭代器遍历的顺序是从小到大的顺序；</li><li>操作效率：查询&#x2F;插入&#x2F;删除的效率都为$O(logn)$；</li><li>排序方式 : 默认使用<code>less</code>仿函数 , 即<code>&lt;</code>运算符进行排序 ; 也可以自定义排序规则仿函数 ;</li><li>使用场景：<strong>需要 集合有序 且 元素不重复 的场景；</strong></li></ul><h5 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h5><ul><li>底层结构 : 底层由 红黑树 实现 , 红黑树 是一种<strong>平衡二叉搜索树</strong> , 存储空间不连续;</li><li>访问遍历 : 不支持 随机访问迭代器 , 不能听过下标访问 , 支持按顺序迭代，迭代器遍历的顺序是从小到大的顺序；</li><li>操作效率：查询 &#x2F; 插入 &#x2F; 删除 效率 为 O(log n) 复杂度;</li><li>排序方式 : 默认使用<code>less</code>仿函数 , 即<code>&lt;</code>运算符进行排序 ; 也可以自定义排序规则仿函数;</li><li>使用场景 : 需要 <strong>集合有序</strong> 且 <strong>元素重复</strong> 的场景;</li></ul><h5 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h5><ul><li>底层结构 : 底层由 <strong>哈希表</strong> 实现 , <strong>存储空间不连续</strong>;</li><li>访问遍历 : 不支持 随机访问迭代器 , 不能听过下标访问;</li><li><strong>操作效率：插入、删除和查找操作的平均时间复杂度为 O(1)，但在最坏情况下可能达到 O(n)；</strong></li><li>使用场景 : 更适合 <strong>频繁插入和查找操作</strong> 且 <strong>不关心元素顺序</strong> 的场景；</li></ul><h4 id="字典系列"><a href="#字典系列" class="headerlink" title="字典系列"></a>字典系列</h4><blockquote><p>[!Tip]</p><p>字典容器 与 集合容器 的区别是字典容器存储的是 <strong>键值对元素 , 是 pair 对象</strong>； 集合容器 存储的是 单纯的 <strong>键单个元素</strong> ;</p></blockquote><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><ul><li>底层结构 : 底层由 红黑树 实现 , 红黑树 是 一种 平衡二叉搜索树 , 存储空间 不连续 ; 存储的 元素 是 键值对 元素;</li><li>访问遍历 : 不支持 随机访问迭代器 , 不能听过下标访问 , 只能通过迭代器进行访问;</li><li>操作效率：查询 &#x2F; 插入 &#x2F; 删除 效率 为 O(log n) 复杂度 ; 与 set 集合容器相同;</li><li>排序方式 : 默认使用<code>less</code>仿函数 , 即<code>&lt;</code>运算符进行排序 ; 也可以自定义排序规则仿函数 ; map 映射容器 不允许重复的键 , multimap 多重映射容器允许重复的键;</li><li>使用场景 : 需要 有序 键值对 且 <strong>元素 不重复</strong> 的场景;</li></ul><h5 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h5><ul><li>底层结构: 底层由 红黑树 实现，红黑树 是 一种 平衡二叉搜索树，存储空间 不连续， 存储的 元素 是 键值对 元素 ;</li><li>访问遍历: 不支持 随机访问迭代器 , 不能听过下标访问 , 只能通过迭代器进行访问 ;</li><li>操作效率：查询 &#x2F; 插入 &#x2F; 删除 效率 为 O(log n) 复杂度 ; 与 set 集合容器相同 ;</li><li>排序方式：默认使用<code>less</code>仿函数 , 即<code>&lt;</code>运算符进行排序 ; 也可以自定义排序规则仿函数 ; map 映射容器 不允许重复的键 , multimap 多重映射容器允许重复的键;</li><li>使用场景: 需要 有序 键值对 且 <strong>元素 重复</strong> 的场景 ;</li></ul><h5 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h5><ul><li>底层结构：set底层是由红黑树实现（红黑树是一种平衡二叉树），存储空间不连续，存储的 元素 是 键值对 元素 ;</li><li><strong>操作效率：插入、删除和查找操作的平均时间复杂度为 O(1)，但在最坏情况下可能达到 O(n)；</strong></li><li>使用场景 : 更适合 <strong>频繁插入和查找操作</strong> 且 <strong>不关心元素顺序</strong> 的场景；</li></ul><h4 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h4><h3 id="模拟链表"><a href="#模拟链表" class="headerlink" title="模拟链表"></a>模拟链表</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> head,idx; <span class="comment">// head是链表的头结点，idx是当前链表指针</span></span><br><span class="line"><span class="type">int</span> e[N],ne[N]; <span class="comment">// e静态链表数组，ne是链表指针数组。即e数组存储节点的值，而ne存储节点的next指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	head=<span class="number">-1</span>; idx=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add2head</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  	e[idx]=c;</span><br><span class="line">  	ne[idx]=head; </span><br><span class="line">  	head=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  	e[idx]=c;</span><br><span class="line">  	ne[idx]=ne[k];</span><br><span class="line">  	ne[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">earse</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  	ne[k]=ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N],l[N],r[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    l[<span class="number">1</span>]=<span class="number">0</span>;r[<span class="number">0</span>]=<span class="number">1</span>;idx=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    l[idx]=a,r[idx]=r[a];</span><br><span class="line">    l[r[a]]=idx,r[a]=idx++;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    l[r[a]]=l[a];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">  	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx]=b;ne[idx]=h[a];h[a]=idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> stk[N],tt;</span><br><span class="line"><span class="comment">//push</span></span><br><span class="line">stk[++tt]=x;</span><br><span class="line"><span class="comment">//pop</span></span><br><span class="line">tt--;</span><br><span class="line"><span class="comment">//judge empty</span></span><br><span class="line"><span class="keyword">if</span>(tt&gt;<span class="number">0</span>) <span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">else</span> empty</span><br><span class="line"><span class="comment">//top of stack</span></span><br><span class="line">stk[tt];</span><br></pre></td></tr></table></figure></div><h3 id="模拟队列"><a href="#模拟队列" class="headerlink" title="模拟队列"></a>模拟队列</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> que[N],hh,tt=<span class="number">-1</span>;  <span class="comment">//hh是队头，tt是队尾</span></span><br><span class="line"><span class="comment">//push</span></span><br><span class="line">que[++tt]=x;</span><br><span class="line"><span class="comment">//pop</span></span><br><span class="line">hh++;</span><br><span class="line"><span class="comment">//judge empty</span></span><br><span class="line"><span class="keyword">if</span>(hh&lt;=tt) <span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">else</span> empty</span><br><span class="line"><span class="comment">//front of queue</span></span><br><span class="line">que[hh];</span><br></pre></td></tr></table></figure></div><p>如果要实现循环队列，只需要每次在插入值时对<code>tt</code>进行判断，如果其等于N就将其赋值为0。或者直接<code>que[++tt%N]=x;</code>，当然这样就要注意操作次数，防止整数溢出。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> que[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;  <span class="comment">// hh是队头，tt是队尾</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> hh == tt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (tt + <span class="number">1</span>) % N == hh;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    que[tt] = x;</span><br><span class="line">    tt = (tt + <span class="number">1</span>) % N;  <span class="comment">// 更新队尾，使用取模实现循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hh = (hh + <span class="number">1</span>) % N;  <span class="comment">// 更新队头，使用取模实现循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> que[hh];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><blockquote><p>[!Caution]</p><p>常见题型：<strong>找出区间每个数左边（右边）离它最近的比它大&#x2F;小的数</strong>，特别是“最近”两字！</p><p><strong>单调增栈求更大，单调减栈求更小</strong></p><p>OJ例题：<a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5788">P5788 【模板】单调栈 - 洛谷 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> stk[N],tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )  <span class="comment">//左边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt--;  <span class="comment">// 单调栈就是始终需要维护一个单调的栈</span></span><br><span class="line">  	<span class="keyword">if</span>(tt) find the value stk[tt];</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">not</span> find;</span><br><span class="line">    stk[++tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i -- )  <span class="comment">//右边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt--;  <span class="comment">// 单调栈就是始终需要维护一个单调的栈</span></span><br><span class="line">  	<span class="keyword">if</span>(tt) find the value stk[tt];</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">not</span> find;</span><br><span class="line">    stk[++tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre.<span class="built_in">push_back</span>(INT_MAX);  <span class="comment">//这一步相当关键，这里push的值需要根据单调增还是减栈确定，增站用max，减栈用min</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123; <span class="comment">//左右两边</span></span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; pre[stk[tt]] &lt;= pre[i]) &#123; <span class="comment">// 单调增栈</span></span><br><span class="line">        <span class="type">int</span> idx = stk[tt--];</span><br><span class="line">        res1[idx] = (tt == <span class="number">0</span> ? <span class="number">-1</span> : stk[tt]);  <span class="comment">//左端</span></span><br><span class="line">        res2[idx] = (i == len ? <span class="number">-1</span> : i);  <span class="comment">//右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    stk[++tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/description/">接雨水 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> N = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res1[N], res2[N];</span><br><span class="line">    <span class="type">int</span> len = height.<span class="built_in">size</span>();</span><br><span class="line">    height.<span class="built_in">push_back</span>(INT_MAX);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; height[stk[tt]] &lt; height[i]) &#123; <span class="comment">// 单调增栈</span></span><br><span class="line">            <span class="type">int</span> idx = stk[tt--];</span><br><span class="line">            res1[idx] = (tt == <span class="number">0</span> ? <span class="number">-1</span> : stk[tt]);</span><br><span class="line">            res2[idx] = (i == len ? <span class="number">-1</span> : i);</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (res1[i] != <span class="number">-1</span> &amp;&amp; res2[i] != <span class="number">-1</span>)</span><br><span class="line">        sum += (<span class="built_in">min</span>(height[res1[i]], height[res2[i]]) - height[i])*(res2[i]-res1[i]<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>[!WARNING]</p><p>这个LeetCode的题“<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/description/">接雨水 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>”，看似可以利用左右两边比其大而形成蓄水部位的特性利用单调栈解题，<del>但是忽略了“最近”这个局部的概念而导致很难正确求解</del>。</p><p><font color="red"><strong>补：利用这个局部也是能正确求解的，使用分层的思想。</strong></font></p><p><img lazyload src="/images/loading.svg" data-src="https://ec28649.webp.li/20250301135119329.png" alt="image-20240822004148780"></p><p><code>height = [0,1,0,4,1,0,1,3,2,1,2,1]</code></p><p>假如把左&#x2F;右没有比起更大的值记为-1，那么每个元素其左边最近更大的下标序列为：</p><p><code>-1 -1 1 -1 3 4 3 3 7 8 7 10</code></p><p>其右边最近更大的下标序列为：</p><p><code>1 3 3 -1 7 6 7 -1 -1 10 -1 -1</code></p><p>将左右两边序列结合观察，只有在<code>2,4,5,6,9</code>这几个位置蓄水（对应位置均不为-1）。第5个位置就暴露出“最近”这个局部概念的问题，其得到的左右两边更大的，能够形成的局部蓄水高度并不是其全局蓄水高度。</p><p>因此，想要从这直接计算每个位置的最大蓄水高度显然是不行的。但也很好解决，只要确定每个可蓄水位的最大蓄水高度就能够完成最终求解。</p><p>左侧最大蓄水高度：<code>[0,1,1,4,4,4,4,4,4,4,4,4]</code></p><p>右侧最大蓄水高度：<code>[4,4,4,4,3,3,3,3,2,2,2,1]</code></p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> N = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> stk[N],tt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lmax[N],rmax[N];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res1,res2;</span><br><span class="line">    <span class="type">int</span> len=height.<span class="built_in">size</span>();</span><br><span class="line">    lmax[<span class="number">0</span>]=height[<span class="number">0</span>],rmax[len<span class="number">-1</span>]=height[len<span class="number">-1</span>];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++) lmax[i]=<span class="built_in">max</span>(lmax[i<span class="number">-1</span>],height[i]); </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--) rmax[i]=<span class="built_in">max</span>(rmax[i+<span class="number">1</span>],height[i]); </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123; <span class="comment">//需要找右边离他最近且比他大or相等的元素</span></span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; height[stk[tt]]&lt;=height[i]) tt--;</span><br><span class="line">        <span class="keyword">if</span>(tt) res1.<span class="built_in">push_back</span>(stk[tt]);</span><br><span class="line">        <span class="keyword">else</span> res1.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        stk[++tt]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    tt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; height[stk[tt]]&lt;=height[i]) tt--;</span><br><span class="line">        <span class="keyword">if</span>(tt) res2.<span class="built_in">push_back</span>(stk[tt]);</span><br><span class="line">        <span class="keyword">else</span> res2.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        stk[++tt]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res1.<span class="built_in">begin</span>(),res1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="keyword">if</span>(res1[i]!=<span class="number">-1</span> &amp;&amp; res2[i]!=<span class="number">-1</span>)</span><br><span class="line">            sum+=<span class="built_in">min</span>(rmax[res1[i]],lmax[res2[i]])-height[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面的方法从左到右和从右到左用了两次单调栈来寻找左边和右边的更大元素。其实这是没必要的，<strong>可以只用一趟就能够同时完成寻找作用两边更大的元素</strong>。</p><p>模板还是一样，但思路有点不同。在两次单调栈中，我们每次都是将外循环<code>for</code>遍历到的元素当成基准元素来找寻离当前基准元素左&#x2F;右边更大的元素。<strong>但是在一次单调栈中，当前遍历到的元素不在基准元素，反而是左&#x2F;右边更大的元素</strong>。</p><p>我们假设外层的<code>for</code>循环是从左到右，且栈是单调增栈。<strong>当外循环遍历到元素<code>i</code>时，此时<code>i</code>为右边界，从内循环<code>while</code>出来后的栈顶元素为基准，下一个栈顶元素为左边界。</strong>此时寻找到左边界和右边界都是比基准元素<strong>更小且最近</strong>的值。</p><p>因此，上面的代码可以进一步优化为：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> N = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lmax[N], rmax[N];</span><br><span class="line">    <span class="type">int</span> res1[N], res2[N];</span><br><span class="line">    <span class="type">int</span> len = height.<span class="built_in">size</span>();</span><br><span class="line">    lmax[<span class="number">0</span>] = height[<span class="number">0</span>], rmax[len - <span class="number">1</span>] = height[len - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) lmax[i] = <span class="built_in">max</span>(lmax[i - <span class="number">1</span>], height[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) rmax[i] = <span class="built_in">max</span>(rmax[i + <span class="number">1</span>], height[i]);</span><br><span class="line">    height.<span class="built_in">push_back</span>(INT_MAX);  <span class="comment">//这一步相当关键</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; height[stk[tt]] &lt;= height[i]) &#123; <span class="comment">// 单调增栈</span></span><br><span class="line">            <span class="type">int</span> idx = stk[tt--];</span><br><span class="line">            res1[idx] = (tt == <span class="number">0</span> ? <span class="number">-1</span> : stk[tt]);</span><br><span class="line">            res2[idx] = (i == len ? <span class="number">-1</span> : i);</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (res1[i] != <span class="number">-1</span> &amp;&amp; res2[i] != <span class="number">-1</span>)</span><br><span class="line">        sum += <span class="built_in">min</span>(lmax[res1[i]], rmax[res2[i]]) - height[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><font color="red">当然，尽管优化成一轮遍历，但其实如果按照这个思路求解，前面的找可蓄水位其实就是没必要的操作了！</font></p><p><font color="orange">因此我们尝试不去计算每个位置左右的最大蓄水高度，只用已求解的局部需水量进行分层计算。</font></p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> N = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res1[N], res2[N];</span><br><span class="line">    <span class="type">int</span> len = height.<span class="built_in">size</span>();</span><br><span class="line">    height.<span class="built_in">push_back</span>(INT_MAX);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; height[stk[tt]] &lt; height[i]) &#123; <span class="comment">// 单调增栈</span></span><br><span class="line">            <span class="type">int</span> idx = stk[tt--];</span><br><span class="line">            res1[idx] = (tt == <span class="number">0</span> ? <span class="number">-1</span> : stk[tt]);</span><br><span class="line">            res2[idx] = (i == len ? <span class="number">-1</span> : i);</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (res1[i] != <span class="number">-1</span> &amp;&amp; res2[i] != <span class="number">-1</span>)</span><br><span class="line">        sum += (<span class="built_in">min</span>(height[res1[i]], height[res2[i]]) - height[i])*(res2[i]-res1[i]<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>类似的还有LeetCode<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，这里构建的就是一个单调递减栈。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> stk[N],tt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = heights.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> maxSize=<span class="number">0</span>;</span><br><span class="line">    heights.<span class="built_in">push_back</span>(INT_MIN);  <span class="comment">//单调递减栈，插INT_MIN；递增栈，插INT_MAX</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; heights[stk[tt]]&gt;=heights[i]) &#123;  <span class="comment">//最近更小，单调减栈，遍历元素需更小；最近更大，单调递增栈，遍历元素需更大</span></span><br><span class="line">            <span class="type">int</span> idx=stk[tt--];</span><br><span class="line">            <span class="type">int</span> left = (tt==<span class="number">0</span> ? <span class="number">-1</span> : stk[tt]);  <span class="comment">//一般左边界都需要特判，右边界视题而定</span></span><br><span class="line">            maxSize=<span class="built_in">max</span>(maxSize,(i-left<span class="number">-1</span>)*heights[idx]);</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++tt]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>假如我们不使用单调栈，则可以想到使用双指针的算法。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = height.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=len<span class="number">-1</span>,maxl=<span class="number">0</span>,maxr=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> wal=<span class="built_in">min</span>(maxl,maxr);</span><br><span class="line">        <span class="keyword">if</span>(height[l]&lt;=wal)&#123;</span><br><span class="line">            res+=wal-height[l++];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(height[r]&lt;=wal)&#123;</span><br><span class="line">            res+=wal-height[r--];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxl=<span class="built_in">max</span>(maxl,height[l]);</span><br><span class="line">        maxr=<span class="built_in">max</span>(maxr,height[r]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></blockquote><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>常见题型：求滑动窗口（窗口大小固定）中的<strong>最值</strong>，<strong>求单调队列中的任意值也可用二分。</strong></p><p><strong>单调队列中存储的都是Index，而不是Value。</strong></p><p>OJ例题：<a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1886">滑动窗口 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>、<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/description/">滑动窗口最大值 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>、<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/">和至少为 K 的最短子数组 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,k;  <span class="comment">// n是数的个数，k是区间长度</span></span><br><span class="line"><span class="type">int</span> arr[N],que[N];  <span class="comment">// arr用来存储数，que是单调队列，其中存储区间元素的下标</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(hh&lt;=tt &amp;&amp; i-que[hh]+<span class="number">1</span>&gt;k) hh++;  <span class="comment">// 如果队列超过区间长度</span></span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt &amp;&amp; arr[que[tt]]&gt;=arr[i]) tt--; <span class="comment">// 维护单调队列，如果当前元素要小于单调队列的队尾元素，则队尾元素弹出，确保队列单调递增，队头能够取到最小值。</span></span><br><span class="line">    que[++tt]=i; <span class="comment">// 将当前元素插入</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[que[hh]]);  <span class="comment">//当窗口全部滑入数组上后判定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="和至少为-K-的最短子数组"><a href="#和至少为-K-的最短子数组" class="headerlink" title="和至少为 K 的最短子数组"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/">和至少为 K 的最短子数组 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h4><p>这个题目很好的将单调队列和前缀和融合在一起！</p><p>这个题目必须用前缀和的原因有两点：</p><p>1、前缀和在计算区间和时只需O(1)的代价</p><p>2、<strong>不用前缀和不能满足题目所要求的连续区间</strong>。因为在获取单调队列时，必然会导致队列中的元素不再连续（虽然相对位置关系依旧保留）。只有使用前缀和，其中的每一个值代表一个区间的和，才在以离散的状态构建单调队列的同时保持连续区间的要求（两个前缀和数组的值作差能表示一个区间的和）。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> N =<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shortestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">    ll sum[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++) sum[i]=sum[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line">    ll que[N],hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    ll minL=INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++)&#123; <span class="comment">//前缀和得从0开始！</span></span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt &amp;&amp; sum[i]-sum[que[hh]]&gt;=k) minL=<span class="built_in">min</span>(minL,i-que[hh++]);</span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt &amp;&amp; sum[que[tt]]&gt;=sum[i]) tt--;</span><br><span class="line">        que[++tt]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minL == INT_MAX ? <span class="number">-1</span> : minL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="环形子数组的最大和"><a href="#环形子数组的最大和" class="headerlink" title="环形子数组的最大和"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">环形子数组的最大和 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h4><p>环形问题拉直处理。依旧是前缀和+单调队列。</p><p>限制是区间长度不大于数组长度。</p><p>当然其实拉直处理，可以用模运算实现，而不是真实地再复制数组一遍。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> N = <span class="number">6e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = nums.<span class="built_in">size</span>(),len=k*<span class="number">2</span>;</span><br><span class="line">    nums.<span class="built_in">insert</span>(nums.<span class="built_in">end</span>(),nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(len+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)sum[i]=sum[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> maxV=INT_MIN;</span><br><span class="line">    <span class="type">int</span> que[N],hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(que,<span class="number">0</span>,<span class="keyword">sizeof</span> que);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hh&lt;=tt &amp;&amp; i-que[hh]&gt;k) hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt &amp;&amp; sum[que[tt]] &gt; sum[i]) tt--;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;k<span class="number">-1</span>) maxV=<span class="built_in">max</span>(maxV,sum[i]-sum[que[hh]]);</span><br><span class="line">        que[++tt]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是一棵完全二叉树，使用数组从1进行存储。堆可以动态的维护一个区间内的最小值&#x2F;最大值。</p><p>向堆中插入一个数：<code>heap[++size]=x;up(size);</code></p><p>求堆中最小值：<code>heap[1];</code></p><p>删除堆中的最小值：<code>swap(heap[1],heap[size]);size--;down(1);</code></p><p>删除堆中任意一个元素：<code>swap(heap[k],heap[size]);size--;down(k);up(k);</code></p><p>修改任意一个元素：<code>heap[k]=c;down(k);up(k);</code></p><p><strong>堆的数组存储是从下标1开始的。</strong></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> h[N],n,size;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  	<span class="type">int</span> tmp=x;</span><br><span class="line">  	<span class="keyword">if</span>(x*<span class="number">2</span>&lt;=size &amp;&amp; h[x*<span class="number">2</span>]&lt;h[tmp]) tmp=x*<span class="number">2</span>;</span><br><span class="line">  	<span class="keyword">if</span>(x*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; h[x*<span class="number">2</span>+<span class="number">1</span>]&lt;h[tmp]) tmp=x*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">if</span>(tmp!=x) &#123;</span><br><span class="line">      <span class="built_in">swap</span>(h[tmp],h[x]);</span><br><span class="line">      <span class="built_in">down</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">while</span>(x/<span class="number">2</span> &amp;&amp; h[x]&lt;h[x/<span class="number">2</span>]) &#123;<span class="built_in">swap</span>(h[x],h[x/<span class="number">2</span>]);x&gt;&gt;=<span class="number">1</span>;&#125;  <span class="comment">//小根堆</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;  <span class="comment">//建堆，时间复杂度为O(n)</span></span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--) <span class="built_in">down</span>(i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  	h[++size]=c;</span><br><span class="line">  	<span class="built_in">up</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="built_in">swap</span>(h[<span class="number">1</span>],h[size]);</span><br><span class="line">  	size--;</span><br><span class="line">  	<span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_k</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  	<span class="built_in">swap</span>(h[k],h[size]);</span><br><span class="line">  	size--;</span><br><span class="line">  	<span class="built_in">down</span>(k);<span class="built_in">up</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">revise</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  	h[k]=c;</span><br><span class="line">  	<span class="built_in">down</span>(k);<span class="built_in">up</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="P3378-【模板】堆-洛谷"><a href="#P3378-【模板】堆-洛谷" class="headerlink" title="P3378 【模板】堆 - 洛谷"></a><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3378">P3378 【模板】堆 - 洛谷 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> h[N],n,size;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp=k;</span><br><span class="line">    <span class="keyword">if</span>(k*<span class="number">2</span>&lt;=size &amp;&amp; h[tmp]&gt;h[k*<span class="number">2</span>]) tmp=k*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(k*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; h[tmp]&gt;h[k*<span class="number">2</span>+<span class="number">1</span>]) tmp=k*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tmp != k) &#123;<span class="built_in">swap</span>(h[tmp],h[k]);<span class="built_in">down</span>(tmp);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k/<span class="number">2</span> &amp;&amp; h[k/<span class="number">2</span>]&gt;h[k]) &#123;<span class="built_in">swap</span>(h[k],h[k/<span class="number">2</span>]);k&gt;&gt;=<span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    h[++size]=x;</span><br><span class="line">    <span class="built_in">up</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(h[<span class="number">1</span>],h[size]);</span><br><span class="line">    size--;</span><br><span class="line">    <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> c,op;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">            <span class="built_in">push</span>(op);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,h[<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="Tire树"><a href="#Tire树" class="headerlink" title="Tire树"></a>Tire树</h3><p>Tire树是一种用来快速<strong>存储字符串集合</strong>，<strong>统计和排序大量的字符串前缀</strong>来减少查询时间，最大限度地减少无谓的字符串比较的数据结构。其特点是字符类别不多（一般就是小写字母、大写字母以及数字），即<strong>一般宽度上限为62&#x3D;26+26+10</strong>，而深度上限是<strong>字符串的长度</strong>。</p><p>Trie树是一种多叉树的结构，<strong>每个节点保存一个字符，一条路径表示一个字符串</strong>。</p><p><img lazyload src="/images/loading.svg" data-src="https://ec28649.webp.li/20250301135135464.png" alt="image-20220321154950133"></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>],cnt[N],idx;  <span class="comment">//son是从0开始存储，而cnt是从1开始存储</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个insert是求完全匹配的字符串数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;  </span><br><span class="line">  	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line">      	<span class="type">int</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      	<span class="keyword">if</span>(!son[p][u]) son[p][u]=++idx; <span class="comment">//son数组中存储的是idx</span></span><br><span class="line">      	p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">  	cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个insert是求前缀匹配的字符串数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;  </span><br><span class="line">  	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line">      	<span class="type">int</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      	<span class="keyword">if</span>(!son[p][u]) son[p][u]=++idx;</span><br><span class="line">      	p=son[p][u];</span><br><span class="line">      	cnt[p]++;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个query是求完全匹配的字符串数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">  	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line">      	<span class="type">int</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      	<span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      	p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个是求最长公共前缀</span></span><br><span class="line"><span class="type">int</span> cur=idx;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=cur;i&gt;<span class="number">0</span>;i--) <span class="keyword">if</span>(cnt[i]&gt;cnt[cur]) cur=i;</span><br><span class="line"><span class="keyword">if</span>(cnt[<span class="number">1</span>]==len) cout&lt;&lt;strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>,cur);</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt; <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure></div><h4 id="P8306-【模板】字典树-洛谷"><a href="#P8306-【模板】字典树-洛谷" class="headerlink" title="P8306 【模板】字典树 - 洛谷"></a><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P8306">P8306 【模板】字典树 - 洛谷 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">65</span>],cnt[N],idx;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> t,n,q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>, u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]&lt;=<span class="string">&#x27;9&#x27;</span>) u=str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i]&lt;=<span class="string">&#x27;Z&#x27;</span>) u=str[i]-<span class="string">&#x27;A&#x27;</span>+<span class="number">11</span>;</span><br><span class="line">        <span class="keyword">else</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">37</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u]=++idx;</span><br><span class="line">        cnt[son[p][u]]++;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>,u=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]&lt;=<span class="string">&#x27;9&#x27;</span>) u=str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i]&lt;=<span class="string">&#x27;Z&#x27;</span>) u=str[i]-<span class="string">&#x27;A&#x27;</span>+<span class="number">11</span>;</span><br><span class="line">        <span class="keyword">else</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">37</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t;j++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);<span class="built_in">insert</span>(str);&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(str));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(son,<span class="number">0</span>,<span class="keyword">sizeof</span> son);</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集是一种用于处理<strong>集合合并与查询问题</strong>的数据结构。并查集通常用于解决一些与集合划分和连接相关的问题，例如：</p><ol><li>连通性问题：<strong>判断两个元素是否属于同一个连通分量</strong>。</li><li>图的最小生成树：在构建最小生成树时，可以使用<strong>并查集来判断是否形成了环路</strong>，从而避免将边加入最小生成树中。</li><li>元素的分类和分组：将元素划分为不相交的组或分类，以便进行高效的组内操作。</li></ol><p><strong>并查集的<code>p</code>数组下标从0开始还是从1开始是根据节点编号从0开始还是从1开始确定的。</strong></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">  	<span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  	p[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>如果需要维护集合大小，需要重新开辟一个以每个节点为根树大小的数组</strong></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N],size[N],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;p[i]=i;size[i]=<span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; </span><br><span class="line">  	<span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">  	<span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(<span class="built_in">find</span>(x)!=<span class="built_in">find</span>(y)) size[<span class="built_in">find</span>(y)]+=size[<span class="built_in">find</span>(x)];</span><br><span class="line">  	p[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="P3367-【模板】并查集-洛谷"><a href="#P3367-【模板】并查集-洛谷" class="headerlink" title="P3367 【模板】并查集 - 洛谷"></a><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集 - 洛谷 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N],n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    p[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> c,x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;c,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">1</span>) <span class="built_in">join</span>(x,y);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">find</span>(x)==<span class="built_in">find</span>(y)?<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;Y&quot;</span>):<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;N&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="树-图"><a href="#树-图" class="headerlink" title="树&amp;图"></a>树&amp;图</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="树的深度优先遍历"><a href="#树的深度优先遍历" class="headerlink" title="树的深度优先遍历"></a><a class="link" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1b7411N798?p=53">树的深度优先遍历 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h4><blockquote><p>[!Note]</p><p>树的遍历有<strong>先根遍历和后根遍历</strong>，其中<strong>二叉树还有中根遍历</strong>，森林的遍历可以基于树的遍历，有<strong>先序遍历和中序遍历</strong>。</p><p><strong>树的先根遍历序列和其对应的二叉树（左孩子右兄弟存储）的先根遍历序列一致，树的后根遍历序列和其对应的二叉树的中根遍历序列一致。</strong></p><p>森林的<strong>先序遍历</strong>序列等价于每棵树按序<strong>先根遍历</strong>的序列，此外还可以将森林使用左孩子右兄弟表示法转化成二叉树再进行<strong>先序遍历</strong>。</p><p>森林的<strong>中序遍历</strong>序列等价于每棵树按序<strong>后根遍历</strong>的序列，此外还可以将森林使用左孩子右兄弟表示法转化成二叉树再进行<strong>中序遍历</strong>。</p><p><img lazyload src="/images/loading.svg" data-src="https://ec28649.webp.li/20250301135145771.png" alt="image-20240827162116725"></p></blockquote><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode *root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;left, res);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;right, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">midorder</span><span class="params">(TreeNode *root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;left, res);</span><br><span class="line">    res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;right, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode *root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;left, res);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;right, res);</span><br><span class="line">  	res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">preorder</span>(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="树的宽度优先遍历"><a href="#树的宽度优先遍历" class="headerlink" title="树的宽度优先遍历"></a>树的宽度优先遍历</h4><blockquote><p>[!Note]</p><p>树的宽度优先遍历的实现逻辑和其二叉树的宽度优先遍历实现逻辑是一致的。</p></blockquote><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><blockquote><p>[!Note]</p><p><font color="green">在搞懂DFS前，需要明白DFS是基于递归的，只有很好的理解递归，才能将DFS用到炉火纯青！</font></p><p>递归最终要的就是两个点：<strong>递归出口和递归点</strong></p><p><strong>递归出口即是什么时候截止</strong>。</p><p>假如遍历一颗BST，需要找到值为5的节点。那么递归出口就有两种情况：当递归到叶节点时终止和当递归找到值为5的节点终止。</p><p><strong>递归点即需要找到当前问题如何转换成其子问题</strong>。</p><p>还是上面那个问题，需要找到值为5的节点。对于当前节点来说，找到值为5的节点有三种可能：当前节点本身值为5，值为5的节点在左子树中，值为5的节点在右子树中。因此问题就向其子空间（子问题）进行了转换，这就是递归点。</p><p>OJ例题：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/description/">深度优先搜索知识点题库 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>如上面这道OJ例题，判断二叉树是否对称。</p><p><strong>其递归出口就有四种情况：左右子树同时递归到叶子结点、左子树递归到叶子结点但右子树没有、右子树递归到叶子结点但左子树没有、左右子树都未递归到叶子结点，但当前存储的值不同。</strong></p><p><strong>递归点就是：左子树的左孩子与右子树的右孩子对称、左子树的右孩子与右子树的左孩子对称。</strong></p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isSame</span>(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> boolean <span class="title">isSame</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == null &amp;&amp; q == null) <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p == null || q == null) || p.val != q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isSame</span>(p.left, q.right) &amp;&amp; <span class="built_in">isSame</span>(p.right, q.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></blockquote><p>时间复杂度O(n+m)，n表示点数，m表示边数</p><p>深搜的关键在于<strong>本状态和下一状态的衔接</strong>以及<strong>递归出口</strong>的设置。</p><p><strong>深搜在网格题目中备受关注！</strong></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(u==n) <span class="keyword">return</span>; <span class="comment">//递归出口</span></span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">//状态记录</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[e[i]]) <span class="built_in">dfs</span>(j); <span class="comment">//进入dfs前有条件限制，则进行了剪枝</span></span><br><span class="line">    &#125;</span><br><span class="line">  	st[u] = <span class="literal">false</span>; <span class="comment">//状态恢复</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="B3621-枚举元组-洛谷"><a href="#B3621-枚举元组-洛谷" class="headerlink" title="B3621 枚举元组 - 洛谷"></a><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/B3621">B3621 枚举元组 - 洛谷 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> n,k,res[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==n) &#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot; &quot;</span>;cout&lt;&lt;endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        res[t]=i;</span><br><span class="line">        <span class="built_in">dfs</span>(t+<span class="number">1</span>);  <span class="comment">//这道题就没有涉及到状态恢复</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="P10448-组合型枚举-洛谷"><a href="#P10448-组合型枚举-洛谷" class="headerlink" title="P10448 组合型枚举 - 洛谷"></a><a class="link" target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P10448">P10448 组合型枚举 - 洛谷 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">26</span>;</span><br><span class="line"><span class="type">int</span> n,k,res[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==n+<span class="number">1</span>) &#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot; &quot;</span>;cout&lt;&lt;endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;res[t<span class="number">-1</span>])&#123; <span class="comment">// 确保递增顺序</span></span><br><span class="line">            res[t]=i;</span><br><span class="line">            <span class="built_in">dfs</span>(t+<span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;k,&amp;n);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>[!IMPORTANT]</p><p>DFS往往有很多变种，无返回值的DFS，带返回值的DFS，无需状态记录的DFS和带状态记录的DFS等。其中，有无返回值和有无状态记录两者并不是冲突对立的。一个DFS的题目可能是无返回值需要状态记录的，也有可能是带返回值无状态记录的。</p><p><strong>无返回值DFS模板：</strong></p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">([<span class="string">&#x27;search space&#x27;</span>,] <span class="string">&#x27;current state parameters&#x27;</span>)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(<span class="string">&#x27;reach of terminal state&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  	<span class="built_in">dfs</span>(<span class="string">&#x27;next state parameters&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>OJ例题：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/description/">岛屿数量 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><strong>带返回值DFS模板：</strong></p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">([<span class="string">&#x27;search space&#x27;</span>,] <span class="string">&#x27;current state parameters&#x27;</span>)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(<span class="string">&#x27;reach of terminal state&#x27;</span>) <span class="keyword">return</span> value;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="string">&#x27;next state parameters&#x27;</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>OJ例题：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-area-of-island/">岛屿的最大面积 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h5 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/description/">岛屿数量 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h5><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> maxn=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> sta[maxn][maxn];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span> || x&gt;=n || y&lt;<span class="number">0</span> || y&gt;=m || sta[x][y] || grid[x][y]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    sta[x][y]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(grid,x+<span class="number">1</span>,y);</span><br><span class="line">    <span class="built_in">dfs</span>(grid,x<span class="number">-1</span>,y);</span><br><span class="line">    <span class="built_in">dfs</span>(grid,x,y+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(grid,x,y<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    n=grid.<span class="built_in">size</span>(),m=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>&amp;&amp; !sta[i][j]) &#123;res++;<span class="built_in">dfs</span>(grid,i,j);&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-area-of-island/">岛屿的最大面积 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h5><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> maxn=<span class="number">60</span>;</span><br><span class="line"><span class="type">bool</span> sta[maxn][maxn];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span> || x&gt;=n || y&lt;<span class="number">0</span> || y&gt;=m || sta[x][y] || grid[x][y]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sta[x][y]=<span class="literal">true</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(grid,x+<span class="number">1</span>,y)+<span class="built_in">dfs</span>(grid,x<span class="number">-1</span>,y)+<span class="built_in">dfs</span>(grid,x,y+<span class="number">1</span>)+<span class="built_in">dfs</span>(grid,x,y<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    n=grid.<span class="built_in">size</span>(),m=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span> &amp;&amp; !sta[i][j])</span><br><span class="line">                res=<span class="built_in">max</span>(res,<span class="built_in">dfs</span>(grid,i,j));</span><br><span class="line">    <span class="keyword">return</span> res;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>[!Tip]</p><p>对于DFS搜索空间是网格的情况，往往需要遍历其上下左右四个访问，因此可以创建两个偏量数组<code>dx和dy</code>，通过<code>for</code>循环进行简便表示。</p></blockquote><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dx=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//void dfs</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">  	<span class="built_in">dfs</span>([<span class="string">&#x27;search space&#x27;</span>,] x+dx[i],y+dy[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int dfs</span></span><br><span class="line"><span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">  	ans+=<span class="built_in">dfs</span>([<span class="string">&#x27;search space&#x27;</span>,] x+dx[i],y+dy[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="宽度优先搜索"><a href="#宽度优先搜索" class="headerlink" title="宽度优先搜索"></a>宽度优先搜索</h4><p>宽搜本身具备<strong>最短路的性质</strong>，<font color="orange">当边权一致时，可以用来求最短路径</font>。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  	st[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">  	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">      	<span class="type">int</span> tmp=q.<span class="built_in">front</span>();</span><br><span class="line">      	q.<span class="built_in">pop</span>();</span><br><span class="line">      	<span class="keyword">for</span>(<span class="type">int</span> i=h[i];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">          	<span class="type">int</span> node=e[i];</span><br><span class="line">          	<span class="keyword">if</span>(!st[node])&#123;</span><br><span class="line">              	st[node]=<span class="literal">true</span>;</span><br><span class="line">              	q.<span class="built_in">push</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="除法求值"><a href="#除法求值" class="headerlink" title="除法求值"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-division/description/">除法求值 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h5><p>这个题目很好的利用了宽度优先搜索的最短路特性！<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-division/solutions/340296/san-chong-jie-fa-by-baymaxhwy">多个视角 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（并查集 | Floyd | DFS | BFS）看这道题。</p><blockquote><p>[!Note]</p><p>顺便借着这个题目梳理一下图相关题目的做法。</p><p>首先，<strong>最重要的是能够识别出这题可以用图做</strong>。其实也很好判断，图最重要的就是<strong>结点与结点之间的关联</strong>，若题目能抽象出<strong>结点</strong>和<strong>结点之间的关联</strong>，且题目求解的答案也需要利用到结点之间的关系，那么这道题很大程度上就要用图解题。</p><p><strong>那么下一步就要思考，答案的求解需要涉及到什么知识</strong>。基于图遍历的求解？最短路问题？最小生成树问题？拓扑排序问题？还是二分图问题？这一步就是问题建模的过程，因此相当关键。这需要我们对这些问题所涉及的模板特别熟悉，且能灵活的改动。</p><p><strong>确定大体的解题思路之后，就要落足于题目实际</strong>。图需要用哪种结构进行存储？邻接矩阵、邻接表、还是结构体数组？这需要根据上一步确定的方法，以及题目数据规模共同敲定。是否需要用到额外的辅助数据结构？堆、队列、集合、哈希表？</p><p><strong>最后就是编码的细节</strong>。是否需要状态记录？DFS的递归出口，返回值是否正确？数组下标从1开始还是从0开始？</p></blockquote><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> maxn= <span class="number">30</span>;</span><br><span class="line"><span class="type">double</span> g[maxn][maxn];</span><br><span class="line"><span class="type">bool</span> st[maxn];</span><br><span class="line">unordered_map &lt;string,<span class="type">int</span>&gt; node;</span><br><span class="line"><span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;  <span class="comment">//这里用dfs是不合题意的，因为不是最短构造</span></span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    st[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;idx;i++)</span><br><span class="line">        <span class="keyword">if</span>(g[x][i] &amp;&amp; !st[i]) <span class="keyword">return</span> <span class="built_in">dfs</span>(i, y) * g[x][i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> tmp[maxn];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++) tmp[i] = <span class="number">1</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(x);</span><br><span class="line">    st[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> top = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">            <span class="keyword">if</span> (!st[i] &amp;&amp; g[top][i]) &#123;</span><br><span class="line">                tmp[i] *= tmp[top] * g[top][i];</span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (top == y) <span class="keyword">return</span> tmp[top];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">calcEquation</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;<span class="type">double</span>&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries)</span> </span>&#123;  <span class="comment">//这个题是很明显的需要用邻接矩阵去存储的</span></span><br><span class="line">    <span class="type">int</span> len=equations.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node.<span class="built_in">count</span>(equations[i][<span class="number">0</span>])) &#123;node.<span class="built_in">insert</span>(&#123;equations[i][<span class="number">0</span>],idx++&#125;);&#125;</span><br><span class="line">        <span class="keyword">if</span>(!node.<span class="built_in">count</span>(equations[i][<span class="number">1</span>])) &#123;node.<span class="built_in">insert</span>(&#123;equations[i][<span class="number">1</span>],idx++&#125;);&#125;</span><br><span class="line">        g[node[equations[i][<span class="number">0</span>]]][node[equations[i][<span class="number">1</span>]]] = values[i];</span><br><span class="line">        g[node[equations[i][<span class="number">1</span>]]][node[equations[i][<span class="number">0</span>]]]=<span class="number">1</span>/values[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:queries)</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="built_in">count</span>(item[<span class="number">0</span>]) &amp;&amp; node.<span class="built_in">count</span>(item[<span class="number">1</span>]))&#123;</span><br><span class="line">            <span class="built_in">init</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">bfs</span>(node[item[<span class="number">0</span>]],node[item[<span class="number">1</span>]]));</span><br><span class="line">        &#125;<span class="keyword">else</span> res.<span class="built_in">push_back</span>(<span class="number">-1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><strong>有向图 | 宽度优先搜索的一种应用</strong></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dim[N],q[N],tp[N],n;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>,idx=<span class="number">0</span>; <span class="comment">// 初始空队列</span></span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!dim[i]) q[++tt]=i; <span class="comment">// 将入度为0的元素放入队列中</span></span><br><span class="line">  	<span class="keyword">while</span>(hh&lt;=tt)&#123; <span class="comment">// 队不空</span></span><br><span class="line">      	<span class="type">int</span> tmp=q[hh++];  <span class="comment">// 取出队头元素</span></span><br><span class="line">      	tp[idx++]=tmp; <span class="comment">// 其实这里也没必要额外开一个tp存储，q中存储的就是拓扑序</span></span><br><span class="line">      	<span class="keyword">for</span>(<span class="type">int</span> i=h[tmp];i!=<span class="number">-1</span>;i=ne[i])  <span class="comment">// 遍历队头元素的出边</span></span><br><span class="line">          	<span class="keyword">if</span>(--d[e[i]]==<span class="number">0</span>) q[++tt]=e[i]; </span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">return</span> tt==n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><p><img lazyload src="/images/loading.svg" data-src="https://ec28649.webp.li/20250301135200899.png" alt="image-20240827000750510"></p><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><h5 id="朴素Dijkstra"><a href="#朴素Dijkstra" class="headerlink" title="朴素Dijkstra"></a>朴素Dijkstra</h5><p>基于邻接矩阵存储的算法。</p><p>时间复杂度是$O(n^2)$，仅支持求正权边的最短路径。算法时间复杂度与边数无关，适用于稠密图。</p><p>算法的基本思想是通过逐步扩展已确定最短路径的顶点集合，从源点开始逐步确定源点到其他顶点的最短路径。Dijkstra算法使用了贪心策略，<strong>每次选择当前距离源点最近的顶点进行扩展，直到所有顶点都被扩展</strong>。</p><ol><li>初始化：将源点的最短路径距离设置为0，其他顶点的最短路径距离设置为正无穷大（或一个足够大的值）。</li><li>选择最短路径顶点：从尚未确定最短路径的顶点中选择一个距离源点最近的顶点，将其标记为已确定最短路径。</li><li>更新最短路径距离：对于选择的顶点，遍历其所有邻接顶点，如果通过该顶点可以获得更短的路径，则更新邻接顶点的最短路径距离为源点经过选择顶点到该邻接顶点的距离。</li><li>重复进行步骤2和步骤3，直到所有顶点都被确定最短路径。</li></ol><p>最短路径获取：<strong>通过记录每个顶点的前驱节点，可以从目标顶点逆向获取最短路径</strong>。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g[N][N],dist[N];</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// g存储每条边的权重，dist存储1号点到其他点的距离，st存储每个节点的最短路径是否确定。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">  	dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123; <span class="comment">// 遍历剩余节点</span></span><br><span class="line">      	<span class="type">int</span> d=<span class="number">-1</span>;</span><br><span class="line">      	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="comment">// 在还未确定最短路的节点中，寻找距离最小的点</span></span><br><span class="line">          	<span class="keyword">if</span>(!st[j]&amp;&amp;(d==<span class="number">-1</span>||dist[d]&gt;dist[j])) d=j;</span><br><span class="line">      	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="comment">// 根据寻找到的节点d更新其他点的距离</span></span><br><span class="line">          	dist[j]=<span class="built_in">min</span>(dist[j],dist[d]+g[d][j]);</span><br><span class="line">      	st[d]=<span class="literal">true</span>; <span class="comment">// 将节点d设置为最短路径确定的点</span></span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="堆优化Dijkstra"><a href="#堆优化Dijkstra" class="headerlink" title="堆优化Dijkstra"></a>堆优化Dijkstra</h5><p>基于邻接表存储的算法。</p><p>时间复杂度是$O(mlogn)$，仅支持求正权边的最短路径。算法时间复杂度与边数有关，适用于稀疏图。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],w[N],n,idx,dist[N];</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st存储每个节点的最短路径是否确定。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">  	priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;heap;</span><br><span class="line">  	heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;); <span class="comment">//插入距离和节点编号</span></span><br><span class="line">  	<span class="keyword">while</span>(!heap.<span class="built_in">empty</span>())&#123;</span><br><span class="line">      	<span class="keyword">auto</span> d=heap.<span class="built_in">top</span>();</span><br><span class="line">      	heap.<span class="built_in">pop</span>();</span><br><span class="line">      	<span class="type">int</span> node=d.second,dis=d.first;</span><br><span class="line">      	<span class="keyword">if</span>(st[node]) <span class="keyword">continue</span>;</span><br><span class="line">      	st[node]=<span class="literal">true</span>;</span><br><span class="line">      	<span class="keyword">for</span>(<span class="type">int</span> i=h[node];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">          	<span class="type">int</span> k=e[i];</span><br><span class="line">          	<span class="keyword">if</span>(dist[k]&gt;dist[node]+w[i])&#123;</span><br><span class="line">              	dist[k]=dist[node]+w[i];</span><br><span class="line">              	heap.<span class="built_in">push</span>(&#123;dist[k],k&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h4><p>基于结构体存储的算法。</p><p><strong>算法的基本思想是通过不断地松弛边来逐步确定源点到其他所有顶点的最短路径</strong>。它使用了<strong>动态规划</strong>的思想，通过对所有边进行<strong>松弛操作</strong>，逐渐更新顶点的最短路径估计值，直到达到最优解。</p><ol><li>初始化：将源点的最短路径估计值设置为0，其他顶点的最短路径估计值设置为正无穷大（或一个足够大的值）。</li><li>进行松弛操作：对图中的每条边进行松弛操作，即根据边的权值更新顶点的最短路径估计值。对于边(u, v)，如果通过 u 可以获得更短的路径，**则更新顶点 v 的最短路径估计值为 dist[u] + weight(u, v)**，其中 dist[u] 表示源点到顶点 u 的最短路径估计值。</li><li>重复进行步骤2：重复进行步骤2，执行 V-1 次松弛操作，其中 V 是图中顶点的数量。这样可以确保在最坏情况下，所有的最短路径都能被找到。</li><li>检测负权回路：<strong>进行第 V 次松弛操作后，如果仍然存在可以进行松弛操作的边，则说明图中存在负权回路，无法得到有效的最短路径</strong>。</li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> dist[N],backup[N]; <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"><span class="keyword">struct</span>&#123; <span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">      	<span class="built_in">memcpy</span>(backup,dist,<span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )&#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">           	dist[b] = <span class="built_in">min</span>(dist[b],backup[a]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="SPFA算法-Shortest-Path-Faster-Algorithm"><a href="#SPFA算法-Shortest-Path-Faster-Algorithm" class="headerlink" title="SPFA算法 (Shortest Path Faster Algorithm)"></a>SPFA算法 (Shortest Path Faster Algorithm)</h4><p>基于邻接表存储的算法。</p><p>SPFA算法通过不断<strong>地松弛边</strong>来逐步确定源点到其他所有顶点的最短路径。与Bellman-Ford算法不同的是，SPFA算法使用了一个<strong>队列来优化松弛操作</strong>的选择，<strong>减少了不必要的松弛次数</strong>，从而提高了算法的效率。</p><ol><li><p>创建一个队列，将源点加入队列，并初始化源点到其他所有顶点的距离为无穷大（或一个足够大的值），源点到自身的距离为0。</p></li><li><p>当队列不为空时，执行以下操作：</p><p>a. 从队列中取出一个顶点作为当前顶点。</p><p>b. 遍历当前顶点的所有邻接顶点：如果通过当前顶点可以获得更短的路径，则更新邻接顶点的距离，并将其加入队列（如果尚未在队列中）。</p></li><li><p>当队列为空时，算法结束。此时，源点到所有其他顶点的最短路径长度已确定。</p></li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> h[N],w[N],e[N],ne[N],dist[N],idx,n;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123; <span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; q.<span class="built_in">push</span>(<span class="number">1</span>); st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[node] = <span class="literal">false</span>; <span class="comment">//当一个点从队列中出队时，需要将对应的 st 数组中的标记设置为 false，表示该点不在队列中了。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[node]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> k = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[k] &gt; dist[node] + w[i])&#123;</span><br><span class="line">                dist[k] = dist[node] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[k])&#123;  <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                    q.<span class="built_in">push</span>(k);st[k] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>判断负环</strong>：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> h[N],w[N],e[N],ne[N],dist[N],cnt[N],idx,n;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123; <span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;st[i]=<span class="literal">true</span>;q.<span class="built_in">push</span>(i);&#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[node] = <span class="literal">false</span>; <span class="comment">//当一个点从队列中出队时，需要将对应的 st 数组中的标记设置为 false，表示该点不在队列中了。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[node]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> k = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[k] &gt; dist[node] + w[i])&#123;</span><br><span class="line">                dist[k] = dist[node] + w[i];</span><br><span class="line">              	cnt[k]=cnt[node]+<span class="number">1</span>;</span><br><span class="line">              	<span class="keyword">if</span>(cnt[k]&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!st[k])&#123;  <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                    q.<span class="built_in">push</span>(k);st[k] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h4><p>基于邻接矩阵存储的算法。</p><p>Floyd算法是一种经典的<strong>动态规划</strong>算法，用于求解所有节点对之间的最短路径。其基本思想是通过<strong>中转节点逐步更新路径</strong>，从而找到最短路径。</p><ol><li>初始化距离矩阵：将每条边的权重存储在距离矩阵 <code>dist</code> 中，如果两个节点之间没有直接的边相连，则将其距离设置为一个较大的值（通常为无穷大）。</li><li>通过中转节点逐步更新路径：对于每一个节点k，考虑从节点i到节点j的路径，判断是否存在通过节点k的更短路径。如果存在，则更新距离矩阵中节点i到节点j的距离为节点i到节点k的距离加上节点k到节点j的距离。</li><li>重复执行第2步，直到所有节点对之间的最短路径都被计算出来。</li><li>最终，距离矩阵 <code>dist</code> 中存储的就是所有节点对之间的最短路径。</li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>,N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>; <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>Prim算法是基于顶点的贪心算法。</p><p>给定一个连通的无向加权图$G &#x3D; (V, E)$，其中$V$是顶点集合，$E$是边集合，每条边有一个权重 $w(u, v)$。Prim算法从<strong>一个初始顶点开始，逐步扩展生成树</strong>，<font color="red">每次选择具有最小权重的边并且该边连接了一个新的顶点</font>。</p><ol><li><p><strong>初始化</strong>：</p><ul><li>选择一个初始顶点，将其加入生成树。</li><li>创建一个集合$T$，用于存储生成树中的顶点，初始时包含初始顶点。</li><li>对于每个顶点，记录从$T$到该顶点的最小边权重（使用<strong>优先队列或最小堆来有效地获取最小边</strong>）。</li></ul></li><li><p><strong>扩展生成树</strong>：</p><ul><li>从优先队列中选择权重最小的边，该边连接了一个在$T$中的顶点和一个不在$T$中的顶点。</li><li>将新顶点加入集合$T$。</li><li>更新优先队列中与新顶点相连的边的权重（如果这些边的权重比当前记录的最小权重小）。</li></ul></li><li><p><strong>重复</strong>：</p><ul><li>重复上述步骤，直到所有顶点都被包含在生成树中。</li></ul></li></ol><h5 id="朴素Prim"><a href="#朴素Prim" class="headerlink" title="朴素Prim"></a>朴素Prim</h5><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N];        <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">            		t = j;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><p>kruskal基于贪心策略，通过逐步选择权重最小的边来构建生成树。</p><p>给定一个连通的无向加权图$G &#x3D; (V, E)$，其中$V$是顶点集合，$E$是边集合，每条边有一个权重 $w(u, v)$。Kruskal算法通过<strong>选择不形成环且权重最小的边</strong>来构建最小生成树。</p><ol><li><p><strong>初始化</strong>：</p><ul><li>创建一个空集合$T$用于存储最小生成树中的边。</li><li>将图中的所有边按权重从小到大排序。</li></ul></li><li><p><strong>选择边</strong>：</p><ul><li>从权重最小的边开始，逐条检查这些边。</li><li>如果当前边连接的两个顶点属于不同的连通分量（即不形成环），则将该边加入集合$T$。</li><li>使用并查集数据结构来高效地检测和合并连通分量。</li></ul></li><li><p><strong>重复</strong>：</p><ul><li>重复上述步骤，直到集合$T$中包含$V-1$条边为止，此时$T$就是图的最小生成树。</li></ul></li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;    <span class="comment">// 存储边</span></span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;e)<span class="type">const</span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> w &lt; e.w;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="comment">// 并查集核心操作</span></span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)&#123;   <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><h4 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h4><p>只要图不含有奇数个环，那么一定能被染色。</p><ol><li>选择一个起始节点作为初始顶点，并将其染成一种颜色（例如红色）。</li><li>对于起始节点的每个邻居节点，将其染成与起始节点不同的颜色（例如蓝色）。</li><li>递归或迭代地对每个邻居节点进行步骤2，将其邻居节点的邻居节点染色，直到所有节点都被染色。</li><li>在染色的过程中，如果发现任意两个相邻节点被染成相同的颜色，说明该图不是二分图。</li><li>如果所有节点都被正确染色，并且没有相邻节点被染成相同的颜色，那么该图是二分图。</li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];       <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (color[j] == <span class="number">-1</span>)</span><br><span class="line">        		<span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, !c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">0</span>))&#123;</span><br><span class="line">        		flag = <span class="literal">false</span>;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h4><p>匈牙利算法是一种解决最大匹配问题的经典算法。它用于在二分图中找到一个最大的匹配，即将尽可能多的边匹配起来。匈牙利算法基于增广路径的思想，其基本思路是通过不断寻找增广路径来增加匹配的边数，直到无法找到增广路径为止。</p><ol><li>初始化匹配：将所有的匹配边置为空。</li><li>对于二分图的每个未匹配顶点，尝试找到增广路径。</li><li>寻找增广路径：从一个未匹配的顶点开始，使用深度优先搜索或广度优先搜索的方法，依次访问与当前顶点相邻的未匹配顶点。如果找到一个未匹配的顶点，则将路径中的边进行翻转，即将原本匹配的边变为非匹配边，将原本非匹配的边变为匹配边。</li><li>重复步骤3，直到无法找到增广路径为止。</li><li>最终，得到的匹配即为二分图的最大匹配。</li></ol><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2;     <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];       <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])&#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))&#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h4><h4 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h4><h3 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h3><h3 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h3><h3 id="计数DP"><a href="#计数DP" class="headerlink" title="计数DP"></a>计数DP</h3><h3 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h3><h3 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h3><h3 id="树型DP"><a href="#树型DP" class="headerlink" title="树型DP"></a>树型DP</h3><h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>Title:</strong> 机式指南</li><li><strong>Author:</strong> Hong Nie</li><li><strong>Created at :</strong> 2025-03-01 13:27:51</li><li><strong>Updated at :</strong> 2025-03-01 13:53:38</li><li><strong>Link:</strong> https://gme-hong.github.io/2025/03/01/机式指南/</li><li><strong>License: </strong>This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/Algorithms/">#Algorithms</a>&nbsp;</li></ul><div class="recommended-article px-2 sm:px-6 md:px-8"><div class="recommended-desktop"><div class="recommended-article-header text-xl md:text-3xl font-bold mt-10"><i aria-hidden="true"></i><span>Recommendation</span></div><div class="recommended-article-group"><a class="recommended-article-item" href="/2024/01/13/XV6-FS/" title="XV6 File System" rel="bookmark"><img src="/images/background-light.jpg" alt="XV6 File System" class="!max-w-none"> <span class="title">XV6 File System</span> </a><a class="recommended-article-item" href="/2023/10/06/ChatGPT/" title="ChatGPT 打开潘多拉魔盒，行业壁垒逐步瓦解" rel="bookmark"><img src="/images/background-light.jpg" alt="ChatGPT 打开潘多拉魔盒，行业壁垒逐步瓦解" class="!max-w-none"> <span class="title">ChatGPT 打开潘多拉魔盒，行业壁垒逐步瓦解</span> </a><a class="recommended-article-item" href="/2024/11/13/Reflections/" title="一封跨越半个世纪的来信引发的思考" rel="bookmark"><img src="/images/background-light.jpg" alt="一封跨越半个世纪的来信引发的思考" class="!max-w-none"> <span class="title">一封跨越半个世纪的来信引发的思考</span></a></div></div><div class="recommended-mobile"><div class="recommended-article-header text-xl md:text-3xl font-bold mt-10"><i aria-hidden="true"></i><span>Recommendation</span></div><div class="recommended-article-group"><a class="recommended-article-item" href="/2024/01/13/XV6-FS/" title="XV6 File System" rel="bookmark"><img src="/images/background-light.jpg" alt="XV6 File System" class="!max-w-none"> <span class="title">XV6 File System</span> </a><a class="recommended-article-item" href="/2023/10/06/ChatGPT/" title="ChatGPT 打开潘多拉魔盒，行业壁垒逐步瓦解" rel="bookmark"><img src="/images/background-light.jpg" alt="ChatGPT 打开潘多拉魔盒，行业壁垒逐步瓦解" class="!max-w-none"> <span class="title">ChatGPT 打开潘多拉魔盒，行业壁垒逐步瓦解</span></a></div></div></div><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/2025/07/22/Undergraduate-Notes/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">Undergraduate Notes</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2024/11/13/Reflections/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">一封跨越半个世纪的来信引发的思考</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">Comments</div><div id="giscus-container"></div><script data-swup-reload-script defer>async function loadGiscus(){const t={src:"https://giscus.app/client.js","data-repo":"gme-hong/gitalk","data-repo-id":"R_kgDOLePdMQ","data-category":"General","data-category-id":"DIC_kwDOLePdMc4Cd3Gc","data-mapping":"title","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"1","data-theme":"preferred_color_scheme","data-lang":"zh-CN","data-input-position":"bottom","data-loading":"not-lazy",crossorigin:"anonymous",async:!0},a=document.createElement("script");for(const e in t)a.setAttribute(e,t[e]);document.getElementById("giscus-container").appendChild(a)}{let t=setTimeout(()=>{loadGiscus(),clearTimeout(t)},1e3)}</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">On this page</div><div class="page-title">机式指南</div><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8F%E4%BB%A4%E8%90%A5%E7%BB%8F%E5%85%B8%E9%A2%98%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">夏令营经典题型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.</span> <span class="nav-text">结构体排序问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.1.1.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.</span> <span class="nav-text">日期类问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4"><span class="nav-number">1.2.1.</span> <span class="nav-text">间隔时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%98%9F%E6%9C%9F"><span class="nav-number">1.2.2.</span> <span class="nav-text">判断星期</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-C-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="nav-number">2.</span> <span class="nav-text">C&#x2F;C++快速入门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="nav-number">3.</span> <span class="nav-text">Python快速入门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F"><span class="nav-number">4.</span> <span class="nav-text">入门模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97"><span class="nav-number">4.1.</span> <span class="nav-text">日期计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.2.</span> <span class="nav-text">进制转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E5%80%BC"><span class="nav-number">4.3.</span> <span class="nav-text">字符串转数值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86"><span class="nav-number">5.</span> <span class="nav-text">数学知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%A8%E6%95%B0"><span class="nav-number">5.1.</span> <span class="nav-text">质数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%A8%E6%95%B0%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="nav-number">5.1.1.</span> <span class="nav-text">质数的判定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E5%AD%90"><span class="nav-number">5.1.2.</span> <span class="nav-text">分解质因子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%83%E6%B0%8F%E7%AD%9B"><span class="nav-number">5.1.3.</span> <span class="nav-text">埃氏筛</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E7%AD%9B"><span class="nav-number">5.1.4.</span> <span class="nav-text">欧拉筛</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A6%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">约数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E8%A7%A3%E7%BA%A6%E6%95%B0"><span class="nav-number">5.2.1.</span> <span class="nav-text">分解约数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0"><span class="nav-number">5.2.2.</span> <span class="nav-text">约数个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">5.2.3.</span> <span class="nav-text">约数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="nav-number">5.2.4.</span> <span class="nav-text">最大公约数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5"><span class="nav-number">6.</span> <span class="nav-text">算法初步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">6.1.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">6.1.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">6.1.2.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">6.1.3.</span> <span class="nav-text">直接插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">6.1.4.</span> <span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">6.1.5.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">6.1.6.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sort%E5%87%BD%E6%95%B0"><span class="nav-number">6.1.7.</span> <span class="nav-text">sort函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86"><span class="nav-number">6.2.</span> <span class="nav-text">二分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86"><span class="nav-number">6.2.1.</span> <span class="nav-text">整数二分</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%80%A7%E4%BA%8C%E5%88%86"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">单调性二分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%B9%E6%80%A7%E4%BA%8C%E5%88%86"><span class="nav-number">6.2.1.2.</span> <span class="nav-text">特性二分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E6%8C%87%E9%92%88%E4%BA%8C%E5%88%86"><span class="nav-number">6.2.1.3.</span> <span class="nav-text">非指针二分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A6%E5%8F%B3%E8%BE%B9%E7%95%8C%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="nav-number">6.2.1.4.</span> <span class="nav-text">左右边界不一致</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E4%BA%8C%E5%88%86"><span class="nav-number">6.2.2.</span> <span class="nav-text">浮点二分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97"><span class="nav-number">6.3.</span> <span class="nav-text">大数运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E5%8A%A0"><span class="nav-number">6.3.1.</span> <span class="nav-text">大数加</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E5%87%8F"><span class="nav-number">6.3.2.</span> <span class="nav-text">大数减</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E4%B9%98"><span class="nav-number">6.3.3.</span> <span class="nav-text">大数乘</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E9%99%A4"><span class="nav-number">6.3.4.</span> <span class="nav-text">大数除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C"><span class="nav-number">6.4.</span> <span class="nav-text">哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E5%93%88%E5%B8%8C"><span class="nav-number">6.4.1.</span> <span class="nav-text">整数哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%89%E9%93%BE%E6%B3%95"><span class="nav-number">6.4.1.1.</span> <span class="nav-text">拉链法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="nav-number">6.4.1.2.</span> <span class="nav-text">开放地址法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="nav-number">6.4.1.2.1.</span> <span class="nav-text">最长连续序列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="nav-number">6.4.2.</span> <span class="nav-text">字符串哈希</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86"><span class="nav-number">6.5.</span> <span class="nav-text">前缀和与差分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">6.5.1.</span> <span class="nav-text">一维前缀和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">6.5.2.</span> <span class="nav-text">二维前缀和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="nav-number">6.5.3.</span> <span class="nav-text">一维差分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="nav-number">6.5.4.</span> <span class="nav-text">二维差分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">6.6.</span> <span class="nav-text">双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">6.6.1.</span> <span class="nav-text">最长回文子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">6.6.2.</span> <span class="nav-text">盛最多水的容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">6.6.3.</span> <span class="nav-text">三数之和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">6.7.</span> <span class="nav-text">位运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="nav-number">6.8.</span> <span class="nav-text">离散化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E5%92%8C"><span class="nav-number">6.8.1.</span> <span class="nav-text">区间和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6"><span class="nav-number">6.9.</span> <span class="nav-text">区间合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="nav-number">6.10.</span> <span class="nav-text">KMP算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">6.10.1.</span> <span class="nav-text">最短回文串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">6.10.2.</span> <span class="nav-text">重复的子字符串</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">7.</span> <span class="nav-text">基础数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#STL"><span class="nav-number">7.1.</span> <span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vector"><span class="nav-number">7.1.1.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deque"><span class="nav-number">7.1.2.</span> <span class="nav-text">deque</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stack"><span class="nav-number">7.1.3.</span> <span class="nav-text">stack</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#queue"><span class="nav-number">7.1.4.</span> <span class="nav-text">queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#priority-queue"><span class="nav-number">7.1.5.</span> <span class="nav-text">priority_queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list"><span class="nav-number">7.1.6.</span> <span class="nav-text">list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97"><span class="nav-number">7.1.7.</span> <span class="nav-text">集合系列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#set"><span class="nav-number">7.1.7.1.</span> <span class="nav-text">set</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#multiset"><span class="nav-number">7.1.7.2.</span> <span class="nav-text">multiset</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unordered-set"><span class="nav-number">7.1.7.3.</span> <span class="nav-text">unordered_set</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E7%B3%BB%E5%88%97"><span class="nav-number">7.1.8.</span> <span class="nav-text">字典系列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#map"><span class="nav-number">7.1.8.1.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#multimap"><span class="nav-number">7.1.8.2.</span> <span class="nav-text">multimap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unordered-map"><span class="nav-number">7.1.8.3.</span> <span class="nav-text">unordered_map</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bitset"><span class="nav-number">7.1.9.</span> <span class="nav-text">bitset</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8"><span class="nav-number">7.2.</span> <span class="nav-text">模拟链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">7.2.1.</span> <span class="nav-text">单链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-number">7.2.2.</span> <span class="nav-text">双链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-number">7.2.3.</span> <span class="nav-text">邻接表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E6%A0%88"><span class="nav-number">7.3.</span> <span class="nav-text">模拟栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97"><span class="nav-number">7.4.</span> <span class="nav-text">模拟队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">7.5.</span> <span class="nav-text">单调栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-number">7.5.1.</span> <span class="nav-text">接雨水</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="nav-number">7.6.</span> <span class="nav-text">单调队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA-K-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">7.6.1.</span> <span class="nav-text">和至少为 K 的最短子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-number">7.6.2.</span> <span class="nav-text">环形子数组的最大和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">7.7.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#P3378-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%A0%86-%E6%B4%9B%E8%B0%B7"><span class="nav-number">7.7.1.</span> <span class="nav-text">P3378 【模板】堆 - 洛谷</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tire%E6%A0%91"><span class="nav-number">7.8.</span> <span class="nav-text">Tire树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#P8306-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%AD%97%E5%85%B8%E6%A0%91-%E6%B4%9B%E8%B0%B7"><span class="nav-number">7.8.1.</span> <span class="nav-text">P8306 【模板】字典树 - 洛谷</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">7.9.</span> <span class="nav-text">并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#P3367-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%B4%9B%E8%B0%B7"><span class="nav-number">7.9.1.</span> <span class="nav-text">P3367 【模板】并查集 - 洛谷</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91-%E5%9B%BE"><span class="nav-number">8.</span> <span class="nav-text">树&amp;图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86"><span class="nav-number">8.1.</span> <span class="nav-text">遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-number">8.1.1.</span> <span class="nav-text">树的深度优先遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-number">8.1.2.</span> <span class="nav-text">树的宽度优先遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">8.1.3.</span> <span class="nav-text">深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B3621-%E6%9E%9A%E4%B8%BE%E5%85%83%E7%BB%84-%E6%B4%9B%E8%B0%B7"><span class="nav-number">8.1.3.1.</span> <span class="nav-text">B3621 枚举元组 - 洛谷</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#P10448-%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE-%E6%B4%9B%E8%B0%B7"><span class="nav-number">8.1.3.2.</span> <span class="nav-text">P10448 组合型枚举 - 洛谷</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="nav-number">8.1.3.3.</span> <span class="nav-text">岛屿数量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="nav-number">8.1.3.4.</span> <span class="nav-text">岛屿的最大面积</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">8.1.4.</span> <span class="nav-text">宽度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC"><span class="nav-number">8.1.4.1.</span> <span class="nav-text">除法求值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">8.2.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-number">8.3.</span> <span class="nav-text">最短路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.1.</span> <span class="nav-text">Dijkstra算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%B4%E7%B4%A0Dijkstra"><span class="nav-number">8.3.1.1.</span> <span class="nav-text">朴素Dijkstra</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E4%BC%98%E5%8C%96Dijkstra"><span class="nav-number">8.3.1.2.</span> <span class="nav-text">堆优化Dijkstra</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bellman-Ford%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.2.</span> <span class="nav-text">Bellman-Ford算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SPFA%E7%AE%97%E6%B3%95-Shortest-Path-Faster-Algorithm"><span class="nav-number">8.3.3.</span> <span class="nav-text">SPFA算法 (Shortest Path Faster Algorithm)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Floyd%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.4.</span> <span class="nav-text">Floyd算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">8.4.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="nav-number">8.4.1.</span> <span class="nav-text">Prim算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%B4%E7%B4%A0Prim"><span class="nav-number">8.4.1.1.</span> <span class="nav-text">朴素Prim</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="nav-number">8.4.2.</span> <span class="nav-text">Kruskal算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-number">8.5.</span> <span class="nav-text">二分图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%93%E8%89%B2%E6%B3%95"><span class="nav-number">8.5.1.</span> <span class="nav-text">染色法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="nav-number">8.5.2.</span> <span class="nav-text">匈牙利算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">9.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">9.1.</span> <span class="nav-text">背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#01%E8%83%8C%E5%8C%85"><span class="nav-number">9.1.1.</span> <span class="nav-text">01背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="nav-number">9.1.2.</span> <span class="nav-text">完全背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="nav-number">9.1.3.</span> <span class="nav-text">多重背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85"><span class="nav-number">9.1.4.</span> <span class="nav-text">分组背包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7DP"><span class="nav-number">9.2.</span> <span class="nav-text">线性DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4DP"><span class="nav-number">9.3.</span> <span class="nav-text">区间DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0DP"><span class="nav-number">9.4.</span> <span class="nav-text">计数DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1DP"><span class="nav-number">9.5.</span> <span class="nav-text">数位统计DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP"><span class="nav-number">9.6.</span> <span class="nav-text">状态压缩DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E5%9E%8BDP"><span class="nav-number">9.7.</span> <span class="nav-text">树型DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="nav-number">9.8.</span> <span class="nav-text">记忆化搜索</span></a></li></ol></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2022</span> - 2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">Hong Nie</a><p class="post-count space-x-0.5"><span>12 posts in total </span><span>43.4k words in total</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">VISITOR COUNT</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">TOTAL PAGE VIEWS</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span> <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.7.1</a></span></div><div>Blog up for <span class="odometer" id="runtime_days"></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/libs/Swup.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/libs/SwupSlideTheme.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/libs/SwupScriptsPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/libs/SwupProgressPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/libs/SwupScrollPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/tools/imageViewer.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/utils.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/main.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/layouts/navbarShrink.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/tools/scrollTopBottom.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/tools/lightDarkSwitch.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/layouts/categoryList.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/tools/localSearch.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/tools/codeBlock.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/layouts/lazyload.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/tools/runtime.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/libs/odometer.min.js"></script><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/assets/odometer-theme-minimal.css"><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/libs/Typed.min.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/plugins/typed.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/libs/mermaid.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/plugins/mermaid.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/libs/minimasonry.min.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/plugins/masonry.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/libs/anime.min.js"></script><div class="post-scripts" data-swup-reload-script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/tools/tocToggle.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/layouts/toc.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.7.1/files/source/js/plugins/tabs.js"></script></div></body></html>