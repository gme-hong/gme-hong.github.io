<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="Nie Hong"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="canonical" href="https://gme-hong.github.io/2024/01/13/xv6-file-system/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="Lab5 文件系统1.文件系统1.1.一些经典的文件系统 FAT文件系统（File Allocation Table）： FAT是一种简单而广泛使用的文件系统，最初用于MS-DOS和Windows操作系统。它具有相对简单的结构，容易实现和维护，但在处理大容量存储和提供高级功能方面存在一些限制。 NTFS（New Technology File System）： NTFS是由Microsoft开发的"><meta property="og:type" content="article"><meta property="og:title" content="xv6 file system"><meta property="og:url" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/index.html"><meta property="og:site_name" content="OpticHong&#39;s Blog"><meta property="og:description" content="Lab5 文件系统1.文件系统1.1.一些经典的文件系统 FAT文件系统（File Allocation Table）： FAT是一种简单而广泛使用的文件系统，最初用于MS-DOS和Windows操作系统。它具有相对简单的结构，容易实现和维护，但在处理大容量存储和提供高级功能方面存在一些限制。 NTFS（New Technology File System）： NTFS是由Microsoft开发的"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041545.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041546.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041547.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041548.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041549.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041550.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041551.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041552.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041553.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041554.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041555.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041556.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041557.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041558.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041559.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041560.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041561.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041562.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041563.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041564.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041565.png"><meta property="og:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041566-0090632.png"><meta property="article:published_time" content="2024-01-13T14:00:51.000Z"><meta property="article:modified_time" content="2024-04-22T06:30:39.947Z"><meta property="article:author" content="OpticHong"><meta property="article:tag" content="xv6"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gme-hong.github.io/2024/01/13/xv6-file-system/202403110041545.png"><link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/images/favicon.ico"><title>xv6 file system - OpticHong</title><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/fonts/Chillax/chillax.css"><style>:root{--preloader-background-color:#fff;--preloader-text-color:#000}@media (prefers-color-scheme:dark){:root{--preloader-background-color:#202124;--preloader-text-color:#fff}}@media (prefers-color-scheme:light){:root{--preloader-background-color:#fff;--preloader-text-color:#000}}@media (max-width:600px){.ml13{font-size:2.6rem!important}}.preloader{display:flex;flex-direction:column;gap:1rem;align-items:center;justify-content:center;position:fixed;padding:12px;top:0;right:0;bottom:0;left:0;width:100vw;height:100vh;background-color:var(--preloader-background-color);z-index:1100;transition:opacity .2s ease-in-out}.ml13{font-size:3.2rem;color:var(--preloader-text-color);letter-spacing:-1px;font-weight:500;font-family:Chillax-Variable,sans-serif;text-align:center}.ml13 .word{display:inline-flex;flex-wrap:wrap;white-space:nowrap}.ml13 .letter{display:inline-block;line-height:1em}</style><div class="preloader"><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/anime.min.js"></script><h1 class="ml13">OpticHong</h1><script>var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });


        anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [100,0],
                translateZ: 0,
                opacity: [0,1],
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i
            }).add({
            targets: '.ml13 .letter',
            translateY: [0,-100],
            opacity: [1,0],
            easing: "easeInExpo",
            duration: 1200,
            delay: (el, i) => 100 + 30 * i
        });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            hidePreloaderAfterTimeout(1000); // Hide after 1000 milliseconds once the window has loaded
        });

        // Backup failsafe: Hide preloader after a maximum of 5000 milliseconds, regardless of the window load event
        hidePreloaderAfterTimeout(5000);

        function hidePreloaderAfterTimeout(delay) {
            setTimeout(function () {
                var preloader = document.querySelector('.preloader');
                preloader.style.opacity = '0';
                setTimeout(function () {
                    preloader.style.display = 'none';
                }, 200);
            }, delay);
        }</script></div><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/assets/build/styles.css"><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/fonts/fonts.css"><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/fonts/Satoshi/satoshi.css"><link href="https://fonts.googleapis.com/css2?family=Tilt+Neon&display=swap" rel="stylesheet"><link href="https://834832894.r.cdn36.com/chinesefonts3/packages/mkwtyt/dist/MaoKenTangYuan/result.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css2?family=Alice&display=swap" rel="stylesheet"><script id="hexo-configurations">window.config={hostname:"gme-hong.github.io",root:"/",language:"en",path:"search.json"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"8px",image_alignment:"center",image_caption:!1,link_icon:!0,title_alignment:"left",headings_top_spacing:{h1:"3rem",h2:"2.5rem",h3:"2.2rem",h4:"2.0rem",h5:"1.6rem",h6:"1.2rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:["Lv.8"]},code_block:{copy:!0,style:"mac",font:{enable:!1,family:"Noto Sans",url:"https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&display=swap"}},toc:{enable:!0,max_depth:6,number:!0,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,recommendation:{enable:!0,title:"Recommendation",limit:3,mobile_limit:2,placeholder:"/images/background-light.jpg",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!0,family:"mkwtyt",url:"https://834832894.r.cdn36.com/chinesefonts3/packages/mkwtyt/dist/MaoKenTangYuan/result.css"},english:{enable:!0,family:"Alice",url:"https://fonts.googleapis.com/css2?family=Alice&display=swap"}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!1},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:!0,open_graph:!0,google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/background-light.jpg",dark:"/images/background-dark.jpg"},title:"Nie Hong's Blog",subtitle:{text:["Fear not you have not admirers as you go along","There is no connoisseur on earth but loves your song"],hitokoto:{enable:!1,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!0,family:"Tilt Neon",url:"https://fonts.googleapis.com/css2?family=Tilt+Neon&display=swap"},social_links:{enable:!0,style:"default",links:{github:"https://github.com/gme-hong",instagram:null,zhihu:null,twitter:"https://twitter.com/OpticHong",email:"gme.niehong@gmail.com","fa-solid fa-square-rss":["feed://fetchrss.com/rss/65ee84c571312e534e0eeb2365ee849e5d114a182303e2e2.atom"]},qrs:{weixin:null}}},plugins:{feed:{enable:!1,type:"atom",path:"atom.xml",limit:20,hub:null,content:null,content_limit:140,content_limit_delim:" ",order_by:"-date",icon:"/images/favicon.jpg",autodiscovery:!0,template:null},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!0,version:"9.3.0"},mathjax:{tags:"none",single_dollars:!0,cjk_width:.9,normal_width:.6,append_css:!0,every_page:!1}},version:"2.6.1",navbar:{auto_hide:!1,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-solid fa-house"},Archives:{path:"/archives/",icon:"fa-solid fa-inbox"},Essays:{path:"/essays/",icon:"fa-solid fa-messages"},Papers:{path:"/papers/",icon:"fa-solid fa-newspaper"},About:{icon:"fa-solid fa-user",submenus:{Me:"/about/",Github:"https://github.com/gme-hong",Gallery:"/masonry/"}}},search:{enable:!0,preload:!0,icon:"fa-solid fa-magnifying-glass"}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:null,show_on_mobile:!0,links:{Tags:{path:"/tags/",icon:"fa-regular fa-tags"},Papers:{path:"/papers/",icon:"fa-solid fa-newspaper"},Archives:{path:"/archives/",icon:"fa-solid fa-inbox"},Categories:{path:"/categories/",icon:"fa-solid fa-layer-group"}}},article_date_format:"auto",categories:{enable:!0,limit:6},tags:{enable:!0,limit:5}},footerStart:"2022/3/10 00:00:00"},window.lang_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},window.data={masonry:!0}</script><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/fontawesome/brands.min.css"><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/fontawesome/solid.min.css"><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/fontawesome/regular.min.css"><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="OpticHong's Blog" type="application/atom+xml">
</head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><main class="page-container" id="swup"><div class="main-content-container"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content"><div class="left"><a class="logo-image" href="/"><img src="/images/favicon.jpg"> </a><a class="logo-title" href="/">OpticHong</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-solid fa-house fa-fw"></i> HOME</a></li><li class="navbar-item"><a href="/archives/"><i class="fa-solid fa-inbox fa-fw"></i> ARCHIVES</a></li><li class="navbar-item"><a href="/essays/"><i class="fa-solid fa-messages fa-fw"></i> ESSAYS</a></li><li class="navbar-item"><a href="/papers/"><i class="fa-solid fa-newspaper fa-fw"></i> PAPERS</a></li><li class="navbar-item"><a class="has-dropdown" href="#" onclick="&#34;return" false;&#34;><i class="fa-solid fa-user fa-fw"></i> ABOUT <i class="fa-solid fa-chevron-down fa-fw"></i></a><ul class="sub-menu"><li><a href="/about/">ME</a></li><li><a target="_blank" rel="noopener" href="https://github.com/gme-hong">GITHUB</a></li><li><a href="/masonry/">GALLERY</a></li></ul></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>HOME </span><i class="fa-solid fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/archives/"><span>ARCHIVES </span><i class="fa-solid fa-inbox fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/essays/"><span>ESSAYS </span><i class="fa-solid fa-messages fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/papers/"><span>PAPERS </span><i class="fa-solid fa-newspaper fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full"><div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" navbar-data-toggle="submenu-About"><span>ABOUT </span><i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i></div><div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-About"><div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl"><a class="text-third-text-color text-xl" href="/about/">ME</a></div><div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl"><a class="text-third-text-color text-xl" target="_blank" rel="noopener" href="https://github.com/gme-hong">GITHUB</a></div><div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl"><a class="text-third-text-color text-xl" href="/masonry/">GALLERY</a></div></div></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/tags/"><span>Tags</span> <i class="fa-regular fa-tags fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/categories/"><span>Categories</span> <i class="fa-solid fa-layer-group fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">5</div><div class="label text-third-text-color text-sm">Tags</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">1</div><div class="label text-third-text-color text-sm">Categories</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">12</div><div class="label text-third-text-color text-sm">Posts</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color text-4xl md:text-6xl font-bold px-2 sm:px-6 md:px-8 py-3">xv6 file system</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/favicon.jpg"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">Nie Hong</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv.8</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2024-01-13 22:51</span> <span class="mobile">2024-01-13 22:51</span> <span class="hover-info">Created</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2024-04-22 14:30:39</span> <span class="mobile">2024-04-22 14:30:39</span> <span class="hover-info">Updated</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/undergraduate/">undergraduate</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/xv6/">xv6</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>7.4k Words</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>29 Mins</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h2 id="Lab5-文件系统"><a href="#Lab5-文件系统" class="headerlink" title="Lab5 文件系统"></a>Lab5 文件系统</h2><h3 id="1-文件系统"><a href="#1-文件系统" class="headerlink" title="1.文件系统"></a>1.文件系统</h3><h4 id="1-1-一些经典的文件系统"><a href="#1-1-一些经典的文件系统" class="headerlink" title="1.1.一些经典的文件系统"></a>1.1.一些经典的文件系统</h4><ol><li><strong>FAT文件系统（File Allocation Table）：</strong> FAT是一种简单而广泛使用的文件系统，最初用于MS-DOS和Windows操作系统。它具有相对简单的结构，容易实现和维护，但在处理大容量存储和提供高级功能方面存在一些限制。</li><li>NTFS（New Technology File System）： NTFS是由Microsoft开发的高性能文件系统，用于Windows NT及其后续版本。它支持更大的文件和分区大小，具有更先进的权限管理、日志记录和元数据特性。</li><li><strong>ext文件系统：</strong><ul><li><strong>ext2：</strong> 是Linux中早期版本使用的文件系统，具有相对简单的结构，不支持日志。</li><li><strong>ext3：</strong> 在ext2的基础上添加了日志功能，提供了更好的稳定性和可靠性。</li><li>ext4：是ext3的后继者，引入了一些性能改进和新特性，支持更大的文件和分区。</li></ul></li><li><strong>HFS和HFS+（Hierarchical File System）：</strong> HFS是由苹果公司用于Macintosh计算机的文件系统。HFS+是其后续版本，引入了更大的文件和卷支持，以及更先进的特性。</li><li><strong>APFS（Apple File System）：</strong>是由苹果公司设计和推出的现代文件系统，用于替代HFS+（Hierarchical File System Plus），并首次引入于macOS High Sierra（10.13）操作系统。</li></ol><h4 id="1-2-xv6fs-文件系统"><a href="#1-2-xv6fs-文件系统" class="headerlink" title="1.2.xv6fs 文件系统"></a>1.2.xv6fs 文件系统</h4><p>今天我们的主角是xv6fs，是一个教学用途的<strong>类 Unix 操作系统</strong>，设计简单，方便学生学习和理解操作系统的基本原理。</p><p>在 xv6 中，文件系统负责管理文件和存储设备上的数据。xv6 使用的文件系统是基于简化的 Unix 文件系统的，包括基本的文件和目录操作、inode 结构等。</p><p>xv6磁盘文件系统的分区图如下：</p><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041545.png" title="image-20240113154758144"><h5 id="1-2-1-boot（引导块）"><a href="#1-2-1-boot（引导块）" class="headerlink" title="1.2.1.boot（引导块）"></a>1.2.1.boot（引导块）</h5><p>Lab2 中学过，这里就不再论述了。</p><h5 id="1-2-2-superblock（超级块）"><a href="#1-2-2-superblock（超级块）" class="headerlink" title="1.2.2.superblock（超级块）"></a>1.2.2.superblock（超级块）</h5><p>存有文件系统的<strong>元信息</strong></p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">superblock</span> &#123;</span></span><br><span class="line">  uint size;         <span class="comment">// 文件系统大小，也就是一共多少块</span></span><br><span class="line">  uint nblocks;      <span class="comment">// 数据块数量</span></span><br><span class="line">  uint ninodes;      <span class="comment">// i结点数量</span></span><br><span class="line">  uint nlog;         <span class="comment">// 日志块数量  </span></span><br><span class="line">  uint logstart;     <span class="comment">// 第一个日志块块号 </span></span><br><span class="line">  uint inodestart;   <span class="comment">// 第一个i结点所在块号</span></span><br><span class="line">  uint bmapstart;    <span class="comment">// 第一个位图块块号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mkfs.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINODES 200</span></span><br><span class="line"><span class="comment">// Disk layout:</span></span><br><span class="line"><span class="comment">// [ boot block | sb block | log | inode blocks | free bit map | data blocks ]</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nbitmap = FSSIZE/(BSIZE*<span class="number">8</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> ninodeblocks = NINODES / IPB + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> nlog = LOGSIZE;</span><br><span class="line"><span class="type">int</span> nmeta;    <span class="comment">// Number of meta blocks (boot, sb, nlog, inode, bitmap)</span></span><br><span class="line"><span class="type">int</span> nblocks;  <span class="comment">// Number of data blocks</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fsfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">superblock</span> <span class="title">sb</span>;</span></span><br><span class="line"><span class="type">char</span> zeroes[BSIZE];</span><br><span class="line">uint freeinode = <span class="number">1</span>;</span><br><span class="line">uint freeblock;</span><br></pre></td></tr></table></figure></div><p>在我们进入xv6系统之后，会输出一段关于超级块<code>sb</code>中存储的信息：</p><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041546.png" title="image-20240113165900467"><p>我们可以看到，<u>整个磁盘一共有1000块</u>，<u>其中有941块是用来存储数据的</u>，<u>有200个索引节点，索引项从第32个块磁盘块开始存储</u>，<u>30条日志记录，日志记录从第2个磁盘块开始存储</u>，而<u>位图区从第58个磁盘块开始存储</u>。</p><h5 id="1-2-3-logblock（日志区）"><a href="#1-2-3-logblock（日志区）" class="headerlink" title="1.2.3.logblock（日志区）"></a>1.2.3.logblock（日志区）</h5><p>在 xv6 文件系统中，日志区是指用于事务日志（transaction log）的一部分存储区域。xv6 使用日志来确保文件系统的一致性，尤其是在面临系统崩溃或中断的情况下。<strong>日志区的主要目的是在进行文件系统更新时，首先记录要执行的所有操作，然后将这些操作一次性写入磁盘</strong>。这样，即使在执行过程中系统崩溃，可以通过日志来恢复到一致的状态。</p><h5 id="1-2-4-inode（索引区）"><a href="#1-2-4-inode（索引区）" class="headerlink" title="1.2.4.inode（索引区）"></a>1.2.4.inode（索引区）</h5><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041547.png" title="image-20240113161746995"> <img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041548.png" title="image-20240113161804816"><blockquote><p>我们现在想想，这个索引可能会存在的位置？</p></blockquote><ul><li>没错，肯定会在磁盘中出现，因为要在磁盘中组织这些文件，因此磁盘中一定会包含文件索引信息</li><li>那么还有可能就是在内存中了，因为进程对文件进行操作都是在内存中进行的，因此内存中必然包含文件的索引信息。</li></ul><p>那么，我们现在讨论的索引区，准确来说是在磁盘中的索引。为了和内存中的索引相区分，我们将磁盘中的索引称为dinode（disk inode）。</p><p>在<code>fs.h</code>中包含对dinode的Definition：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT)</span></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEV only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEV only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><ol><li><strong><code>type</code>：</strong> 短整型（<code>short</code>），表示文件的类型。可能的取值包括：<ul><li><code>T_DIR</code>：目录</li><li><code>T_FILE</code>：普通文件</li><li><code>T_DEV</code>：设备文件</li></ul></li><li><strong><code>major</code>：</strong> 短整型（<code>short</code>），仅在文件类型为设备文件（<code>T_DEV</code>）时有意义，表示主设备号。</li><li><strong><code>minor</code>：</strong> 短整型（<code>short</code>），仅在文件类型为设备文件（<code>T_DEV</code>）时有意义，表示次设备号。</li><li><strong><code>nlink</code>：</strong> 短整型（<code>short</code>），表示指向该 inode 的<strong>硬链接数</strong>。</li><li><strong><code>size</code>：</strong> 无符号整型（<code>uint</code>），表示<u>文件的大小</u>（以字节为单位）。</li><li><strong><code>addrs[NDIRECT+1]</code>：</strong> 无符号整型数组，用于存储<strong>文件数据块的地址</strong>。<code>NDIRECT</code> 是一个常量，表示<strong>直接数据块的个数</strong>。这个数组包含了<strong>直接数据块和一级间接数据块的地址</strong>。如果文件很小，数据块地址可以直接存储在 <code>addrs</code> 数组中；<strong>如果文件较大，会使用一级间接块来存储更多的数据块地址</strong>。</li></ol><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041549.png" title="image-20240113162842066"><p>了解了dinode，我们趁热打铁，继续了解内存中的inode。</p><p>内存中的inode被一个叫<code>icache</code>的结构所组织，在<code>fs.c</code>中进行定义：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">inode</span>[<span class="title">NINODE</span>];</span></span><br><span class="line">&#125; icache;</span><br></pre></td></tr></table></figure></div><ol><li><strong><code>struct spinlock lock</code>：</strong> 自旋锁，用于对整个 <code>icache</code> 结构进行加锁。由于 inode 缓存是一个共享的数据结构，多个线程同时访问时需要使用锁来保护共享资源的一致性。</li><li><strong><code>struct inode inode[NINODE]</code>：</strong><font color="orange"><font color="orange">inode数组</font></font> ，包含了 NINODE 个 <code>struct inode</code> 结构体。<code>NINODE</code> 是一个常量，表示 inode 缓存中可以缓存的 inode 的数量。每个 <code>struct inode</code> 表示一个文件或目录的元数据信息，包括文件类型、大小、指向数据块的地址等。</li></ol><p>在<code>file.h</code>中对inode进行定义：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file.h</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>我们可以看到，除了有跟dinode一致的数据项之外，还有一些额外数据项：</p><ol><li><strong><code>uint dev</code>：</strong> 无符号整型（<code>uint</code>），表示该 inode 所在的设备的设备号。</li><li><strong><code>uint inum</code>：</strong> 无符号整型（<code>uint</code>），<strong>表示该 inode 的编号，即该 inode 在设备上的唯一标识符</strong>。</li><li><strong><code>int ref</code>：</strong> 整型（<code>int</code>），表示<strong>对该 inode 的引用计数</strong>。引用计数用于跟踪有多少个指针（例如，打开文件描述符）引用了这个 inode。<font color="cornflowerblue">当引用计数为零时，inode 可以被释放</font>。</li><li><strong><code>struct sleeplock lock</code>：</strong> 一个睡眠锁（sleeping lock），用于保护 <code>struct inode</code> 中除了 <code>lock</code> 自身之外的其他字段。睡眠锁是一种同步机制，它允许线程在访问被锁定资源时进入睡眠状态。</li><li><strong><code>int valid</code>：</strong> 整型（<code>int</code>），表示该 inode 是否已经从磁盘读取并被标记为有效。当 <code>valid</code> 为 1 时，表示该 inode 包含的信息已经被读取到内存中。</li></ol><hr><h6 id="Ex5-1-请解释为-icache-添加的锁-与-为-inode-添加的锁不同的原因？"><a href="#Ex5-1-请解释为-icache-添加的锁-与-为-inode-添加的锁不同的原因？" class="headerlink" title="Ex5-1 请解释为 icache 添加的锁 与 为 inode 添加的锁不同的原因？"></a>Ex5-1 请解释为 icache 添加的锁 与 为 inode 添加的锁不同的原因？</h6><hr><h5 id="1-2-5-bitmap（位图区）"><a href="#1-2-5-bitmap（位图区）" class="headerlink" title="1.2.5.bitmap（位图区）"></a>1.2.5.bitmap（位图区）</h5><p>在理论课中，我们学过，位图是一种磁盘空间管理的方案。</p><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041550.png" title="image-20240113165302182"><p>这里补充一个大家容易误解的知识点：数据块的分配和释放由位图来管理，但位图管理的区域不止数据区，而是<strong>整个文件系统</strong>。</p><p>位图块中每一位都代表着<strong>一块</strong>，该位置 <strong>1 表示相应的块正在使用</strong>，该位置 <strong>0 表示相应的块空闲</strong>。</p><h5 id="1-2-6-data（数据区）"><a href="#1-2-6-data（数据区）" class="headerlink" title="1.2.6.data（数据区）"></a>1.2.6.data（数据区）</h5><p>数据区没啥好说的，只要记住一个点：以块为单位进行存储，可能会产生块内碎片；数据区的存储由位图区进行管理。</p><p>到这里，我们就能对单个文件的检索过程有一个清晰的认知：</p><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041551.png" title="image-20240113175030759"><blockquote><p>除了上述一些在磁盘分区中直接体现的结构之外，文件系统还有一些重要的结构需要我们去了解。</p></blockquote><hr><blockquote><p>我们先试想一下，索引极大的方便了数据块的查找，但其依然是对于文件系统内部而言的。我们平常去检索一个文件从来没有说，通过索引项去找到该文件的吧。相反，我们总是通过文件的文件名去检索文件。因此，还必须有一个结构去实现这种 ”按名存取“ 的功能。这就是目录！</p></blockquote><h5 id="1-2-7-directory（目录）"><a href="#1-2-7-directory（目录）" class="headerlink" title="1.2.7.directory（目录）"></a>1.2.7.directory（目录）</h5><p>在xv6中，跟目录有关的结构体被定义在<code>fs.h</code>中：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs.h</span></span><br><span class="line"><span class="comment">// Directory is a file containing a sequence of dirent structures.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><ol><li><code>ushort inum</code>：无符号短整型，<strong>表示该目录项对应的 inode 号</strong>。</li><li><code>char name[DIRSIZ]</code>：字符数组，表示目录项的名字。<code>DIRSIZ</code> 是一个常量，表示目录项名字的最大长度。</li></ol><p>其中，每一个dirent结构体被称为目录项。在 xv6 操作系统中，目录项存储在磁盘的<strong>数据块</strong>中。每个目录都有一个对应的 inode，而目录项信息实际上被存储在该目录的数据块中。这个数据块包含了一系列的目录项，每个目录项都表示一个文件或子目录。</p><p>我们在xv6的终端中输入<code>ls</code>命令，既可以看到根目录的目录结构：</p><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041552.png" title="image-20240113172648618"><p>我们使用xv6提供的终端命令<code>mkdir</code>自己创建一个目录<code>mydir</code>，再在改目录下通过<code>echo</code>命令创建两个文件</p><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041553.png" title="image-20240113173057913"><p>之后我们在使用<code>ls</code>命令查看根目录的结构</p><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041554.png" title="image-20240113173116276"><p>我们来解释一下<code>ls</code>输出的内容：</p><ul><li>第一列表示文件名，其中“.”表示本目录，”..“表示父目录（根目录的父目录就是其自身）</li></ul><style>.ufxcwsettcdh{zoom:50%}</style><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041555.png" class="ufxcwsettcdh" alt="image-20240113173229906"><ul><li>第二列表示文件类别，我们知道，在Unix操作系统中，”一切皆文件“的思想，在<code>stat.h</code>中，给出了三种文件类型：</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR  1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE 2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEV  3   <span class="comment">// Device</span></span></span><br></pre></td></tr></table></figure></div><p>其中1表示目录文件，2表示数据文件，3表示设备文件。</p><p>我们可以看到“.”和”..“以及我们创建的“mydir”都是目录文件，而console是设备文件</p><ul><li>第三列表示inode编号，这是直接在目录项中存在的，其数值必然是唯一的。</li><li>第四列表示文件的大小，这是在目录项中没有的，因此我们可以推断，<code>ls</code>命令应该既访问了目录项，又访问了inode结点。</li></ul><p>很显然，这种目录的组织结构就是我们熟知的树型结构</p><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041556.png" title="image-20240113172607369"><p>那么，假如我们要检索创建的“myfile1”文件，就需要按照树型结构的路径一层层往下找。当然，不同的起始出发点就会出现两种寻找策略：直接从根节点出发寻找和从当前目录项出发寻找。但是不管是哪一种策略，其都是一个递归的过程。</p><hr><blockquote><p>到这里，我们都还是介绍一些”共性“的结构，或者说概念。但是每一个文件肯定是不同，我们还需要一种能体现”特性“的结构体来表示每一个文件。</p></blockquote><h5 id="1-2-8-file（文件结构体）"><a href="#1-2-8-file（文件结构体）" class="headerlink" title="1.2.8.file（文件结构体）"></a>1.2.8.file（文件结构体）</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE &#125; type;</span><br><span class="line">  <span class="type">int</span> ref; <span class="comment">// 引用计数</span></span><br><span class="line">  <span class="type">char</span> readable; <span class="comment">// 文件是否可读</span></span><br><span class="line">  <span class="type">char</span> writable; <span class="comment">// 文件是否可写</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// 管道文件</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span> <span class="comment">// 关联的 inode</span></span><br><span class="line">  uint off; <span class="comment">// 读写位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><ol><li><strong><code>num &#123; FD_NONE, FD_PIPE, FD_INODE &#125; type</code>：</strong> 表示文件类型的枚举。文件可以是普通文件（<code>FD_INODE</code>）、管道文件（<code>FD_PIPE</code>）或者无效的文件（<code>FD_NONE</code>）。</li><li><strong><code>int ref</code>：</strong> 引用计数，用于追踪有多少个文件描述符引用了这个文件。引用计数用于文件的释放，当引用计数为零时，文件可以被释放。</li><li><strong><code>char readable</code> 和 <code>char writable</code>：</strong> 标志文件是否可读和可写。这两个字段表示了文件的访问权限。</li><li><strong><code>struct pipe \*pipe</code>：</strong> 如果文件是管道文件，这个字段指向管道结构体。</li><li><strong><code>struct inode \*ip</code>：</strong> 指向文件关联的 inode 结构体，用于获取文件的元数据信息。</li><li><strong><code>uint off</code>：</strong> 当前文件的读写位置，表示下一次读写操作将在文件中的哪个位置发生。</li></ol><hr><blockquote><p>接下来我们还得再了解一个概念：文件描述符，这是在<strong>进程</strong>中直接使用的一个结构。</p></blockquote><h5 id="1-2-9-文件描述符"><a href="#1-2-9-文件描述符" class="headerlink" title="1.2.9.文件描述符"></a>1.2.9.文件描述符</h5><p>进程使用文件并不使用file结构体或inode结构体，而是提供文件的路径名来打开文件并获得文件描述符，后续将使用文件描述符来指代这个打开的文件。xv6中，每个进程都有一个文件描述符表<code>proc-&gt;ofile[]</code>，最多可以使用NOFILE&#x3D;16个文件描述符（也就是说一个进程最多同时打开16个文件），每个文件描述符都直接指向一个file结构体（系统管理的已打开的文件）。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//proc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>现在，我们可以站在整个文件系统的层次对一个进程访问文件的整个过程有一个宏观的认知：</p><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041557.png" title="image-20240113181318963"><h3 id="2-文件系统操作"><a href="#2-文件系统操作" class="headerlink" title="2.文件系统操作"></a>2.文件系统操作</h3><h4 id="2-1-盘块操作"><a href="#2-1-盘块操作" class="headerlink" title="2.1.盘块操作"></a>2.1.盘块操作</h4><p><strong>文件系统的所有操作中，对盘块的操作是最底层的，是直接和硬件（设备驱动程序）打交道的。</strong></p><p>在介绍盘块操作之前，我必须先指出大家可能模棱两可的问题：</p><p><font color="red">对盘块的操作并不是直接在磁盘中对盘块进行操作，而是对映射到内存中的块缓存进行操作</font>，至于原因，我觉得大家都明白。<font color="orange">对一个盘块的多次读写操作都是在内存中完成的，直到换出到磁盘上才真正地执行写盘操作</font>。</p><p>xv6fs只能通过块缓存来访问磁盘，而不允许直接访问。</p><h5 id="2-1-1-盘块缓冲区"><a href="#2-1-1-盘块缓冲区" class="headerlink" title="2.1.1.盘块缓冲区"></a>2.1.1.盘块缓冲区</h5><p>在xv6的<code>buf.c</code>中有对缓冲区的定义：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//buf.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// head.next is most recently used.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure></div><ol><li><strong><code>struct spinlock lock</code>：</strong> 互斥锁，用于对整个缓冲区缓存进行加锁。由于缓冲区缓存是一个共享的数据结构，多个线程同时访问时需要使用锁来保护共享资源的一致性。</li><li><strong><code>struct buf buf[NBUF]</code>：</strong> 缓冲区数组，包含 NBUF 个 <code>struct buf</code> 结构体。每个元素表示一个缓冲区，用于缓存磁盘上的数据块。</li><li><strong><code>struct buf head</code>：</strong> <code>struct buf</code> 结构体，用作链表的头部。通过 <code>head.next</code> 和 <code>head.prev</code> 可以构建一个双向链表，用于管理所有缓冲区。<code>head.next</code> 指向最近使用的缓冲区，<code>head.prev</code> 指向最久未使用的缓冲区。</li></ol><p>对每一个缓冲单元在<code>buf.h</code>中进行定义：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//buf.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">qnext</span>;</span> <span class="comment">// disk queue</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B_VALID 0x2  <span class="comment">// buffer has been read from disk</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B_DIRTY 0x4  <span class="comment">// buffer needs to be written to disk</span></span></span><br></pre></td></tr></table></figure></div><ol><li><strong><code>int flags</code>：</strong> 整型，用于表示缓冲区的状态标志。这些标志可能包括：<ul><li><code>B_VALID</code>：缓冲区包含有效的数据。</li><li><code>B_DIRTY</code>：缓冲区中的数据已经被修改，需要写回磁盘。</li><li>其他标志用于表示缓冲区的状态。</li></ul></li><li><strong><code>uint dev</code>：</strong> 无符号整型，表示数据块所在的设备的设备号。</li><li><strong><code>uint blockno</code>：</strong> 无符号整型，表示数据块的块号。这是指在设备上的位置。</li><li><strong><code>struct sleeplock lock</code>：</strong> 一个睡眠锁（sleeping lock），用于对缓冲区进行加锁。睡眠锁是一种同步机制，它允许线程在访问被锁定资源时进入睡眠状态。</li><li><strong><code>uint refcnt</code>：</strong> 无符号整型，表示缓冲区的引用计数。<strong>引用计数用于跟踪有多少个指针引用了这个缓冲区。当引用计数为零时，缓冲区可以被释放。</strong></li><li><strong><code>struct buf *prev</code> 和 <code>struct buf *next</code>：</strong> 指向双向链表中前一个和后一个缓冲区的指针。这些指针用于在缓冲区之间构建 <strong>LRU（Least Recently Used）缓存列表</strong>，<strong>以实现缓冲区的管理和替换</strong>。</li><li><strong><code>struct buf *qnext</code>：</strong> 指向缓冲区的下一个缓冲区，用于构建磁盘 I&#x2F;O 队列。这个指针用于将缓冲区连接到待写回磁盘的队列中。</li><li><strong><code>uchar data[BSIZE]</code>：</strong> 字节数组，用于存储实际的数据块。<code>BSIZE</code> 是一个常量，表示数据块的大小。</li></ol><h5 id="2-1-2-初始化"><a href="#2-1-2-初始化" class="headerlink" title="2.1.2.初始化"></a>2.1.2.初始化</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">  binit();         <span class="comment">// buffer cache</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bio.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line"><span class="comment">//PAGEBREAK!</span></span><br><span class="line">  <span class="comment">// Create linked list of buffers</span></span><br><span class="line">  bcache.head.prev = &amp;bcache.head;</span><br><span class="line">  bcache.head.next = &amp;bcache.hfead;</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>初始化就干两件事：</p><ol><li>创建bcache自旋锁</li><li>将缓存块buf构成一个LRU双向链表</li></ol><p>希望同学们不要把大部分精力陷入到代码的具体理解中，这没意义！</p><h5 id="2-1-3-查找"><a href="#2-1-3-查找" class="headerlink" title="2.1.3.查找"></a>2.1.3.查找</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bio.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached; recycle an unused buffer.</span></span><br><span class="line">  <span class="comment">// Even if refcnt==0, B_DIRTY indicates a buffer is in use</span></span><br><span class="line">  <span class="comment">// because log.c has modified it but not yet committed it.</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span> &amp;&amp; (b-&gt;flags &amp; B_DIRTY) == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;flags = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>根据设备号和盘块号查找块缓存。需要注意的是，盘块缓冲区是对磁盘空间进行了抽象，抽象成了一个连续的空间。而对磁盘缓冲块的查找也相当的粗暴，直接for循环遍历！</p><h5 id="2-1-4-释放"><a href="#2-1-4-释放" class="headerlink" title="2.1.4.释放"></a>2.1.4.释放</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bio.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// no one is waiting for it.</span></span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PAGEBREAK!</span></span><br><span class="line"><span class="comment">// Blank page.</span></span><br></pre></td></tr></table></figure></div><p>释放的代码很简单，需要注意的就是进行<code>b-&gt;refcnt--;</code>操作。</p><hr><p><font color="red">后续还有很多函数，考虑到文章的篇幅，这里我们不再贴代码，会指明代码所在的文件，同学们自行查找即可！</font></p><hr><h5 id="2-1-5-盘块的读写"><a href="#2-1-5-盘块的读写" class="headerlink" title="2.1.5.盘块的读写"></a>2.1.5.盘块的读写</h5><p>请注意，<font color="orange">盘块的读写指的都是从缓存块和磁盘块直接交互的过程！</font></p><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041558.png" title="image-20240113185835790"><p>读写函数都定义在<code>bio.c</code>中，<code>bread()</code>先调用<code>bget()</code>查找对应的缓存块，然后调用<code>iderw()</code>将数据块从磁盘中写入缓存区中；而bwrite()就是调用<code>iderw()</code>将数据块写回磁盘。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bread</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  b = bget(dev, blockno);</span><br><span class="line">  <span class="keyword">if</span>((b-&gt;flags &amp; B_VALID) == <span class="number">0</span>) &#123;</span><br><span class="line">    iderw(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>这个读函数还是给大家贴出来，因为后面做实验要用到。</p></blockquote><h5 id="2-1-6-读入超级块"><a href="#2-1-6-读入超级块" class="headerlink" title="2.1.6.读入超级块"></a>2.1.6.读入超级块</h5><p>超级块的读入有点特殊（很正常，人家名字就已经很特殊了），有专门的在<code>fs.c</code>中的<code>readsb()</code>。</p><blockquote><p>嘿嘿，要不同学猜猜，为什么要抽离出来，定义一个专门的函数来读这个盘块？</p></blockquote><hr><h6 id="Ex5-2-请解释为什么要单独定义一个超级块的读入函数？"><a href="#Ex5-2-请解释为什么要单独定义一个超级块的读入函数？" class="headerlink" title="Ex5-2 请解释为什么要单独定义一个超级块的读入函数？"></a>Ex5-2 请解释为什么要单独定义一个超级块的读入函数？</h6><hr><blockquote><p>骚微提示一下，同学们想想这个盘块是在什么时候开始读的，哈哈哈，只能提示这么多了。</p></blockquote><h5 id="2-1-7-其他函数"><a href="#2-1-7-其他函数" class="headerlink" title="2.1.7.其他函数"></a>2.1.7.其他函数</h5><p>还有几个比较重要的函数是<code>bzero</code>、<code>balloc</code>、<code>bfree</code>，具体干嘛的，同学们自行查阅相关资料。</p><h4 id="2-2-索引节点操作"><a href="#2-2-索引节点操作" class="headerlink" title="2.2.索引节点操作"></a>2.2.索引节点操作</h4><p>对索引节点的操作是抽象在对磁盘操作的基础之上的，具体有对索引节点管理的文件的读写，以及对节点自身的分配，删除和修改。</p><h5 id="2-1-1-对索引节点自身的操作"><a href="#2-1-1-对索引节点自身的操作" class="headerlink" title="2.1.1.对索引节点自身的操作"></a>2.1.1.对索引节点自身的操作</h5><p>主要的函数有<code>iget</code>、<code>iupdate</code>、<code>idup</code>、<code>itrunc</code>、<code>stati</code>、<code>ilock</code>、<code>iunlock</code>、<code>iput</code>，都在<code>fs.c</code>中。</p><p><code>iget()</code>根据设备号dev和索引节点inum在索引节点缓存中查找，返回所匹配的索引节点缓存，或者分配一个空闲的索引节点缓存。</p><p><code>iupdate()</code>将inode缓存的内容更新到磁盘的dinode上，最后写回磁盘中。</p><p><code>idup()</code>增加索引节点缓存的引用计数，将其成员变量ref++即可。</p><p><code>itrunc()</code>将索引节点管理的文件数据（直接块和间接块）都释放掉，每个盘块通过<code>bfree()</code>释放</p><p><code>stati()</code>将索引节点缓存中的基本信息复制到stat结构体中并返回。</p><p><code>iput()</code>减少索引节点缓存的引用计数，将其成员变量ref–，若小于0则<code>itrunc</code>。</p><h5 id="2-1-2-对文件的操作"><a href="#2-1-2-对文件的操作" class="headerlink" title="2.1.2.对文件的操作"></a>2.1.2.对文件的操作</h5><p>主要的函数有<code>readi</code>、<code>bmap</code>、<code>writei</code>，都在<code>fs.c</code>中。</p><p><code>readi()</code></p><p>用于从 inode 对应的磁盘文件的偏移 off 处，读入n个字节到 dst 指向的数据缓冲区。如果是设备文件(T_DEV)，则使用设备的读操作函数 devsw[ip-&gt;major]。read()完成读入操作,否则将执行磁盘文件的读入操作,该操作略微有些复杂。</p><p><strong>磁盘文件需要逐个盘块读入数据,但首先要知道文件偏移量对应的物理盘块号是哪个,这是通过 bmap()完成的。</strong></p><p>确定盘块号之后,将会调用前面讨论过的 bread()完成磁盘盘块的读人。由于 bread()将数据读入到块缓存中,因此还需要用 memmove()将数据复制到用户空间缓冲区。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">readi</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">char</span> *dst, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint tot, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEV)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV || !devsw[ip-&gt;major].read)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> devsw[ip-&gt;major].read(ip, dst, n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(off + n &gt; ip-&gt;size)</span><br><span class="line">    n = ip-&gt;size - off;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, dst+=m)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));</span><br><span class="line">    m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line">    memmove(dst, bp-&gt;data + off%BSIZE, m);</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>这个读函数还是给大家贴出来，因为后面做实验要用到。</p></blockquote><p><code>bmap()</code><br>由于进程发出的文件读写操作使用的是字节偏移(转换成文件内部的逻辑盘块号bn)，而磁盘读写 bread()和 bwrite()使用的是物理盘块号，因此需要 bmap()将文件字节偏移对应的逻辑盘块号 bn 转换成物理盘块号。其转换过程需要借助索引节点的 dinode.addrs[]或 inode.addrs[]，并且需要考虑直接盘块和间接盘块。</p><p>如果对应的数据盘块不存在,则 bmap() 会调用 balloc() 分配一个空闲盘块,然后再修改索引，使得 ip-&gt;addrs[bn] 指向新分配的盘块；如果该偏移落人间接索引区,则可能还需要分配间接索引盘块,然后才能分配盘块号bn所对应的数据盘块并建立索引关系。</p><p><code>writei()</code><br>writei()需要逐个盘块写出数据,因为有块缓存的存在,其会先调用 bread()将磁盘盘块读入到块缓存，然后才是将数据复制到块缓存中，最后由 log_write()向日志系统写出。writei()也是借用 bmap()，通过查找 dinode.addrs[]完成文件偏移量到磁盘盘块号的转换。</p><p>如果是设备(T_DEV),则需要通过它自身的读函数 devsw[ip-&gt;major].read 完成。</p><h4 id="2-3-目录操作"><a href="#2-3-目录操作" class="headerlink" title="2.3.目录操作"></a>2.3.目录操作</h4><p>这一部分我们直接略过了，其主要函数都在<code>fs.c</code>中，如用于目录查找的函数：<code>dirlookup</code>、<code>skipelem</code>；用于创建和删除的函数：<code>dirlink</code>；用于文件定位的函数：<code>namex</code>、<code>namei</code>、<code>nameiparent</code>，其均在<code>fs.c</code>中实现。</p><h4 id="2-4-文件操作"><a href="#2-4-文件操作" class="headerlink" title="2.4.文件操作"></a>2.4.文件操作</h4><h5 id="2-4-1-文件打开表初始化"><a href="#2-4-1-文件打开表初始化" class="headerlink" title="2.4.1.文件打开表初始化"></a>2.4.1.文件打开表初始化</h5><p>在<code>file.c</code>中有<code>fileinit</code>的定义：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fileinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;ftable.lock, <span class="string">&quot;ftable&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">  fileinit();      <span class="comment">// file table</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>用于对系统中已打开文件列表ftable[]进行初始化，即初始化ftable.lock自旋锁</p><h5 id="2-4-2-分配、关闭和复制"><a href="#2-4-2-分配、关闭和复制" class="headerlink" title="2.4.2.分配、关闭和复制"></a>2.4.2.分配、关闭和复制</h5><p><code>filealloc</code>分配一个空闲的file对象</p><p><code>filedup</code>当用户进程对某个文件描述符进行复制时，将引起对应的file对象引用次数加一</p><p><code>fileclose</code>类似<code>iput</code></p><p><code>filestat</code>读取文件的元数据</p><h5 id="2-4-3-文件读写操作"><a href="#2-4-3-文件读写操作" class="headerlink" title="2.4.3.文件读写操作"></a>2.4.3.文件读写操作</h5><p><code>fileread()</code>是通用的文件读操作函数，当文件的type为FD_PIPE将调用piperead()进行读，而为FD_INODE时，调用readi()进行读。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fileread</span><span class="params">(<span class="keyword">struct</span> file *f, <span class="type">char</span> *addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;readable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_PIPE)</span><br><span class="line">    <span class="keyword">return</span> piperead(f-&gt;pipe, addr, n);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>((r = readi(f-&gt;ip, addr, f-&gt;off, n)) &gt; <span class="number">0</span>)</span><br><span class="line">      f-&gt;off += r;</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;fileread&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>这个读函数还是给大家贴出来，因为后面做实验要用到。</p></blockquote><p><code>filewrite()</code>是通用的文件写操作函数，与读操作类似，也通过type分别调用具体的写函数。</p><h4 id="2-5-系统调用"><a href="#2-5-系统调用" class="headerlink" title="2.5.系统调用"></a>2.5.系统调用</h4><p>系统调用在Lab4中已经讲过，为此我们不再做过多赘述。本节课的系统调用的重点就是关注那些与文件操作相关的系统调用，如<code>sys_open</code>、<code>sys_close</code>、<code>sys_read</code>、<code>sys_write</code>、<code>sys_mkdir</code>、<code>sys_mknod</code>等</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span> || argint(<span class="number">2</span>, &amp;n) &lt; <span class="number">0</span> || argptr(<span class="number">1</span>, &amp;p, n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> fileread(f, p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>由于我们后面的实验会用到sys_read()，因此各位重点了解一下这个函数。</p><h3 id="3-实验"><a href="#3-实验" class="headerlink" title="3.实验"></a>3.实验</h3><p>文件系统的内容相当庞大，涉及的概念多吗，因此容易弄混是很常见的事。笔者在上理论课的时候也就在这块理解的不是特别丝滑，因为诸位应该秉着从全局到末端的策略，反复理解。</p><p>那么，我们现在结合一个简单的实验，帮助同学们从进程、文件系统（内存到外存）到设备驱动，这整个文件读的操作理解清楚。</p><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041559.png" title="image-20240113205721509"><h4 id="3-1-gdbinit配置文件断点设置"><a href="#3-1-gdbinit配置文件断点设置" class="headerlink" title="3.1.gdbinit配置文件断点设置"></a>3.1.gdbinit配置文件断点设置</h4><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">layout src</span><br><span class="line"></span><br><span class="line">break sysfile.c:sys_read</span><br><span class="line">break file.c:fileread</span><br><span class="line">break fs.c:readi</span><br><span class="line">break bio.c:bread</span><br><span class="line">break ide.c:iderw</span><br></pre></td></tr></table></figure></div><h4 id="3-2-编译xv6-启动gdb"><a href="#3-2-编译xv6-启动gdb" class="headerlink" title="3.2.编译xv6&amp;启动gdb"></a>3.2.编译xv6&amp;启动gdb</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make qume-nox-gdb</span><br><span class="line">gdb</span><br></pre></td></tr></table></figure></div><h4 id="3-3-具体过程"><a href="#3-3-具体过程" class="headerlink" title="3.3.具体过程"></a>3.3.具体过程</h4><p>Step1：在gdb中：通过info breakpoints检查断点</p><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041560.png" title="image-20240113210843772"><p>Step2：取消断点2,3,4,5</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disable <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></div><p>Step3：continue</p><p>在gdb中输入一个c之后，程序执行到第一个断点位置，此时xv6终端呈现如下，但依旧不能输入。</p><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041561.png" title="image-20240113211155390"><p>在输入第二个c后，程序进入死循环，此时终端可以使用，即开中断已打开。</p><p>Step4：在xv6中输入<code>cat README</code>，即读README文件，并将内容输出到终端中。</p><p>此时，产生中断，截停在sys_read函数中</p><p>Step5：此时我们在gdb中恢复断点2,3,4,5</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></div><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041562.png" title="image-20240113211724588"><p>然后，我们逐行调试，在第78行进入函数fileread中。</p><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041563.png" title="image-20240113211913594"><p>再接着逐行调试，会在107行进入readi函数中。</p><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041564.png" title="image-20240113212046641"><p>再继续，此时可能会读写多个缓存块。在470行进入bread函数中。</p><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041565.png" title="image-20240113212320321"><p>最后，通过设备驱动程序读取文件，在103行进入iderw函数中。</p><p>Step7：当你继续c后，直到xv6终端中出现这么一大段字符，就说明已经从磁盘中读取了一个块的内容。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NOTE: we have stopped maintaining the x86 version of xv6, and switched</span><br><span class="line">our efforts to the RISC-V version</span><br><span class="line">(https://github.com/mit-pdos/xv6-riscv.git)</span><br><span class="line"></span><br><span class="line">xv6 is a re-implementation of Dennis Ritchie&#x27;s and Ken Thompson&#x27;s Unix</span><br><span class="line">Version 6 (v6).  xv6 loosely follows the structure and style of v6,</span><br><span class="line">but is implemented for a modern x86-based multiprocessor using ANSI C.</span><br><span class="line"></span><br><span class="line">ACKNOWLEDGMENTS</span><br><span class="line"></span><br><span class="line">xv6 is inspired by John Lions&#x27;s Commentary on UNIX 6th Edition (Peer</span><br><span class="line">to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14</span><br></pre></td></tr></table></figure></div><p>读者可以数一下，这一共多少个字符。如果是512个，那么恭喜，你数对了。字符数就是一个块的大小（512B）。</p><p>当然，读者再继续c几下还会出现更多的内容。我们直到README文件的大小为2286B，那么算下来，读者应该会执行5次c命令才算把这个文件读完。</p><p>Step8：做到这里，基本上这个小实验就算完成了。做完这些，读者应该大致对这个文件读的过程有了一个宏观的了解。至于这个后面，文件名是如何传递的，索引号是如何检索的，读者如果感兴趣，可以自行探索。</p><p>最后，我们再留一个小作业。我们刚带诸位了解了文件读的过程，那么文件写的执行过程是怎样的，请同学们自行实验探索。</p><hr><h5 id="Ex5-3-请分析echo-“0”-mydir-myfile3这条命令的执行过程，要求对执行过程经过的几个关键的写函数进行分析和截图，并绘制如下，关于写过程的流程图。"><a href="#Ex5-3-请分析echo-“0”-mydir-myfile3这条命令的执行过程，要求对执行过程经过的几个关键的写函数进行分析和截图，并绘制如下，关于写过程的流程图。" class="headerlink" title="Ex5-3 请分析echo “0” &gt; /mydir/myfile3这条命令的执行过程，要求对执行过程经过的几个关键的写函数进行分析和截图，并绘制如下，关于写过程的流程图。"></a>Ex5-3 请分析<code>echo “0” &gt; /mydir/myfile3</code>这条命令的执行过程，要求对执行过程经过的几个关键的写函数进行分析和截图，并绘制如下，关于写过程的流程图。</h5><hr><img lazyload src="/images/loading.svg" data-src="/2024/01/13/xv6-file-system/202403110041566-0090632.png" title="image-20240113213612673"></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>Title:</strong> xv6 file system</li><li><strong>Author:</strong> Nie Hong</li><li><strong>Created at :</strong> 2024-01-13 22:00:51</li><li><strong>Updated at :</strong> 2024-04-22 14:30:39</li><li><strong>Link:</strong> https://gme-hong.github.io/2024/01/13/xv6-file-system/</li><li><strong>License: </strong>This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/xv6/">#xv6</a>&nbsp;</li></ul><div class="recommended-article px-2 sm:px-6 md:px-8"><div class="recommended-desktop"><div class="recommended-article-header text-xl md:text-3xl font-bold mt-10"><i aria-hidden="true"></i><span>Recommendation</span></div><div class="recommended-article-group"><a class="recommended-article-item" href="/2023/10/06/ChatGPT/" title="ChatGPT 打开潘多拉魔盒，行业壁垒逐步瓦解" rel="bookmark"><img src="/images/background-light.jpg" alt="ChatGPT 打开潘多拉魔盒，行业壁垒逐步瓦解" class="!max-w-none"> <span class="title">ChatGPT 打开潘多拉魔盒，行业壁垒逐步瓦解</span> </a><a class="recommended-article-item" href="/2024/03/17/一次惊心动魄的train/" title="A thrilling train" rel="bookmark"><img src="/images/background-light.jpg" alt="A thrilling train" class="!max-w-none"> <span class="title">A thrilling train</span> </a><a class="recommended-article-item" href="/2024/05/05/teenager/" title="正青年，正迷惘" rel="bookmark"><img src="/images/background-light.jpg" alt="正青年，正迷惘" class="!max-w-none"> <span class="title">正青年，正迷惘</span></a></div></div><div class="recommended-mobile"><div class="recommended-article-header text-xl md:text-3xl font-bold mt-10"><i aria-hidden="true"></i><span>Recommendation</span></div><div class="recommended-article-group"><a class="recommended-article-item" href="/2023/10/06/ChatGPT/" title="ChatGPT 打开潘多拉魔盒，行业壁垒逐步瓦解" rel="bookmark"><img src="/images/background-light.jpg" alt="ChatGPT 打开潘多拉魔盒，行业壁垒逐步瓦解" class="!max-w-none"> <span class="title">ChatGPT 打开潘多拉魔盒，行业壁垒逐步瓦解</span> </a><a class="recommended-article-item" href="/2024/03/17/一次惊心动魄的train/" title="A thrilling train" rel="bookmark"><img src="/images/background-light.jpg" alt="A thrilling train" class="!max-w-none"> <span class="title">A thrilling train</span></a></div></div></div><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/2024/03/11/%E4%B9%85%E8%BF%9D%E7%9A%84%E6%94%BE%E6%99%B4/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">久违的放晴</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2023/10/06/ChatGPT/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">ChatGPT 打开潘多拉魔盒，行业壁垒逐步瓦解</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">Comments</div><div id="giscus-container"></div><script data-swup-reload-script defer>async function loadGiscus(){const t={src:"https://giscus.app/client.js","data-repo":"gme-hong/gitalk","data-repo-id":"R_kgDOLePdMQ","data-category":"General","data-category-id":"DIC_kwDOLePdMc4Cd3Gc","data-mapping":"title","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"1","data-theme":"preferred_color_scheme","data-lang":"zh-CN","data-input-position":"bottom","data-loading":"not-lazy",crossorigin:"anonymous",async:!0},a=document.createElement("script");for(const e in t)a.setAttribute(e,t[e]);document.getElementById("giscus-container").appendChild(a)}{let t=setTimeout(()=>{loadGiscus(),clearTimeout(t)},1e3)}</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">On this page</div><div class="page-title">xv6 file system</div><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.</span> <span class="nav-text">Lab5 文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.</span> <span class="nav-text">1.文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.一些经典的文件系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-xv6fs-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2.xv6fs 文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-1-boot%EF%BC%88%E5%BC%95%E5%AF%BC%E5%9D%97%EF%BC%89"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">1.2.1.boot（引导块）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-2-superblock%EF%BC%88%E8%B6%85%E7%BA%A7%E5%9D%97%EF%BC%89"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">1.2.2.superblock（超级块）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-3-logblock%EF%BC%88%E6%97%A5%E5%BF%97%E5%8C%BA%EF%BC%89"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">1.2.3.logblock（日志区）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-4-inode%EF%BC%88%E7%B4%A2%E5%BC%95%E5%8C%BA%EF%BC%89"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">1.2.4.inode（索引区）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Ex5-1-%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%BA-icache-%E6%B7%BB%E5%8A%A0%E7%9A%84%E9%94%81-%E4%B8%8E-%E4%B8%BA-inode-%E6%B7%BB%E5%8A%A0%E7%9A%84%E9%94%81%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="nav-number">1.1.2.4.1.</span> <span class="nav-text">Ex5-1 请解释为 icache 添加的锁 与 为 inode 添加的锁不同的原因？</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-5-bitmap%EF%BC%88%E4%BD%8D%E5%9B%BE%E5%8C%BA%EF%BC%89"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">1.2.5.bitmap（位图区）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-6-data%EF%BC%88%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%89"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">1.2.6.data（数据区）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-7-directory%EF%BC%88%E7%9B%AE%E5%BD%95%EF%BC%89"><span class="nav-number">1.1.2.7.</span> <span class="nav-text">1.2.7.directory（目录）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-8-file%EF%BC%88%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%89"><span class="nav-number">1.1.2.8.</span> <span class="nav-text">1.2.8.file（文件结构体）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-9-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">1.1.2.9.</span> <span class="nav-text">1.2.9.文件描述符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.</span> <span class="nav-text">2.文件系统操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E7%9B%98%E5%9D%97%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1.盘块操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-%E7%9B%98%E5%9D%97%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">2.1.1.盘块缓冲区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">2.1.2.初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-3-%E6%9F%A5%E6%89%BE"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">2.1.3.查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-4-%E9%87%8A%E6%94%BE"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">2.1.4.释放</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-%E7%9B%98%E5%9D%97%E7%9A%84%E8%AF%BB%E5%86%99"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">2.1.5.盘块的读写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-6-%E8%AF%BB%E5%85%A5%E8%B6%85%E7%BA%A7%E5%9D%97"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">2.1.6.读入超级块</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Ex5-2-%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8D%95%E7%8B%AC%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%B6%85%E7%BA%A7%E5%9D%97%E7%9A%84%E8%AF%BB%E5%85%A5%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">1.2.1.6.1.</span> <span class="nav-text">Ex5-2 请解释为什么要单独定义一个超级块的读入函数？</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-7-%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.1.7.</span> <span class="nav-text">2.1.7.其他函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2.索引节点操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-%E5%AF%B9%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E8%87%AA%E8%BA%AB%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">2.1.1.对索引节点自身的操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-2-%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2.1.2.对文件的操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3.目录操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4.文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-1-%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">2.4.1.文件打开表初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-2-%E5%88%86%E9%85%8D%E3%80%81%E5%85%B3%E9%97%AD%E5%92%8C%E5%A4%8D%E5%88%B6"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">2.4.2.分配、关闭和复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-3-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">2.4.3.文件读写操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.5.系统调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AE%9E%E9%AA%8C"><span class="nav-number">1.3.</span> <span class="nav-text">3.实验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-gdbinit%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%AD%E7%82%B9%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1.gdbinit配置文件断点设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E7%BC%96%E8%AF%91xv6-%E5%90%AF%E5%8A%A8gdb"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2.编译xv6&amp;启动gdb</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3.具体过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Ex5-3-%E8%AF%B7%E5%88%86%E6%9E%90echo-%E2%80%9C0%E2%80%9D-mydir-myfile3%E8%BF%99%E6%9D%A1%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%8C%E8%A6%81%E6%B1%82%E5%AF%B9%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%BB%8F%E8%BF%87%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E7%9A%84%E5%86%99%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%E5%92%8C%E6%88%AA%E5%9B%BE%EF%BC%8C%E5%B9%B6%E7%BB%98%E5%88%B6%E5%A6%82%E4%B8%8B%EF%BC%8C%E5%85%B3%E4%BA%8E%E5%86%99%E8%BF%87%E7%A8%8B%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E3%80%82"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">Ex5-3 请分析echo “0” &gt; &#x2F;mydir&#x2F;myfile3这条命令的执行过程，要求对执行过程经过的几个关键的写函数进行分析和截图，并绘制如下，关于写过程的流程图。</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2022</span> - 2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">Nie Hong</a><p class="post-count space-x-0.5"><span>12 posts in total </span><span>14k words in total</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">VISITOR COUNT</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">TOTAL PAGE VIEWS</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span> <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.1</a></span></div><div>Blog up for <span class="odometer" id="runtime_days"></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/Swup.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/SwupSlideTheme.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/SwupScriptsPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/SwupProgressPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/SwupScrollPlugin.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/tools/imageViewer.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/utils.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/main.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/layouts/navbarShrink.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/tools/scrollTopBottom.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/tools/lightDarkSwitch.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/layouts/categoryList.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/tools/localSearch.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/tools/codeBlock.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/layouts/lazyload.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/tools/runtime.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/odometer.min.js"></script><link rel="stylesheet" href="//evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/assets/odometer-theme-minimal.css"><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/Typed.min.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/plugins/typed.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/mermaid.min.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/plugins/mermaid.js"></script><script src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/libs/minimasonry.min.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/plugins/masonry.js"></script><div class="post-scripts" data-swup-reload-script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/tools/tocToggle.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/layouts/toc.js"></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.6.1/source/js/plugins/tabs.js"></script></div></body></html>